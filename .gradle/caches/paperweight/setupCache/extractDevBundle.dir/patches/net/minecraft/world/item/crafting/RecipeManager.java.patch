--- a/net/minecraft/world/item/crafting/RecipeManager.java
+++ b/net/minecraft/world/item/crafting/RecipeManager.java
@@ -10,8 +10,10 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.IdentityHashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalInt;
 import java.util.SortedMap;
@@ -23,132 +25,179 @@
 import net.minecraft.core.registries.Registries;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.server.packs.resources.ResourceManager;
-import net.minecraft.server.packs.resources.SimpleJsonResourceReloadListener;
-import net.minecraft.server.packs.resources.SimplePreparableReloadListener;
-import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.flag.FeatureFlagSet;
+import net.minecraft.world.item.Item;
 import net.minecraft.world.item.crafting.display.RecipeDisplay;
 import net.minecraft.world.item.crafting.display.RecipeDisplayEntry;
 import net.minecraft.world.item.crafting.display.RecipeDisplayId;
 import net.minecraft.world.level.Level;
 import org.slf4j.Logger;
 
+// CraftBukkit start
+import java.util.Collections;
+import net.minecraft.server.MinecraftServer;
+// CraftBukkit end
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.packs.resources.ResourceManager;
+import net.minecraft.server.packs.resources.SimpleJsonResourceReloadListener;
+import net.minecraft.server.packs.resources.SimplePreparableReloadListener;
+import net.minecraft.util.profiling.ProfilerFiller;
+
 public class RecipeManager extends SimplePreparableReloadListener<RecipeMap> implements RecipeAccess {
+
     private static final Logger LOGGER = LogUtils.getLogger();
-    private static final Map<ResourceKey<RecipePropertySet>, RecipeManager.IngredientExtractor> RECIPE_PROPERTY_SETS = Map.of(
-        RecipePropertySet.SMITHING_ADDITION,
-        recipe -> recipe instanceof SmithingRecipe smithingRecipe ? smithingRecipe.additionIngredient() : Optional.empty(),
-        RecipePropertySet.SMITHING_BASE,
-        recipe -> recipe instanceof SmithingRecipe smithingRecipe ? smithingRecipe.baseIngredient() : Optional.empty(),
-        RecipePropertySet.SMITHING_TEMPLATE,
-        recipe -> recipe instanceof SmithingRecipe smithingRecipe ? smithingRecipe.templateIngredient() : Optional.empty(),
-        RecipePropertySet.FURNACE_INPUT,
-        forSingleInput(RecipeType.SMELTING),
-        RecipePropertySet.BLAST_FURNACE_INPUT,
-        forSingleInput(RecipeType.BLASTING),
-        RecipePropertySet.SMOKER_INPUT,
-        forSingleInput(RecipeType.SMOKING),
-        RecipePropertySet.CAMPFIRE_INPUT,
-        forSingleInput(RecipeType.CAMPFIRE_COOKING)
-    );
+    private static final Map<ResourceKey<RecipePropertySet>, RecipeManager.IngredientExtractor> RECIPE_PROPERTY_SETS = Map.of(RecipePropertySet.SMITHING_ADDITION, (irecipe) -> {
+        Optional optional;
+
+        if (irecipe instanceof SmithingRecipe smithingrecipe) {
+            optional = smithingrecipe.additionIngredient();
+        } else {
+            optional = Optional.empty();
+        }
+
+        return optional;
+    }, RecipePropertySet.SMITHING_BASE, (irecipe) -> {
+        Optional optional;
+
+        if (irecipe instanceof SmithingRecipe smithingrecipe) {
+            optional = smithingrecipe.baseIngredient();
+        } else {
+            optional = Optional.empty();
+        }
+
+        return optional;
+    }, RecipePropertySet.SMITHING_TEMPLATE, (irecipe) -> {
+        Optional optional;
+
+        if (irecipe instanceof SmithingRecipe smithingrecipe) {
+            optional = smithingrecipe.templateIngredient();
+        } else {
+            optional = Optional.empty();
+        }
+
+        return optional;
+    }, RecipePropertySet.FURNACE_INPUT, RecipeManager.forSingleInput(RecipeType.SMELTING), RecipePropertySet.BLAST_FURNACE_INPUT, RecipeManager.forSingleInput(RecipeType.BLASTING), RecipePropertySet.SMOKER_INPUT, RecipeManager.forSingleInput(RecipeType.SMOKING), RecipePropertySet.CAMPFIRE_INPUT, RecipeManager.forSingleInput(RecipeType.CAMPFIRE_COOKING));
     private final HolderLookup.Provider registries;
-    public RecipeMap recipes = RecipeMap.EMPTY;
-    private Map<ResourceKey<RecipePropertySet>, RecipePropertySet> propertySets = Map.of();
-    private SelectableRecipe.SingleInputSet<StonecutterRecipe> stonecutterRecipes = SelectableRecipe.SingleInputSet.empty();
-    private List<RecipeManager.ServerDisplayInfo> allDisplays = List.of();
-    private Map<ResourceKey<Recipe<?>>, List<RecipeManager.ServerDisplayInfo>> recipeToDisplay = Map.of();
+    public RecipeMap recipes;
+    private Map<ResourceKey<RecipePropertySet>, RecipePropertySet> propertySets;
+    private SelectableRecipe.SingleInputSet<StonecutterRecipe> stonecutterRecipes;
+    private List<RecipeManager.ServerDisplayInfo> allDisplays;
+    private Map<ResourceKey<Recipe<?>>, List<RecipeManager.ServerDisplayInfo>> recipeToDisplay;
 
     public RecipeManager(HolderLookup.Provider registries) {
+        this.recipes = RecipeMap.EMPTY;
+        this.propertySets = Map.of();
+        this.stonecutterRecipes = SelectableRecipe.SingleInputSet.empty();
+        this.allDisplays = List.of();
+        this.recipeToDisplay = Map.of();
         this.registries = registries;
     }
 
     @Override
-    protected RecipeMap prepare(ResourceManager resourceManager, ProfilerFiller profilerFiller) {
-        SortedMap<ResourceLocation, Recipe<?>> sortedMap = new TreeMap<>();
-        SimpleJsonResourceReloadListener.scanDirectory(
-            resourceManager,
-            Registries.elementsDirPath(Registries.RECIPE),
-            this.registries.createSerializationContext(JsonOps.INSTANCE),
-            Recipe.CODEC,
-            sortedMap
-        );
-        List<RecipeHolder<?>> list = new ArrayList<>(sortedMap.size());
-        sortedMap.forEach((id, recipe) -> {
-            ResourceKey<Recipe<?>> resourceKey = ResourceKey.create(Registries.RECIPE, id);
-            RecipeHolder<?> recipeHolder = new RecipeHolder<>(resourceKey, recipe);
-            list.add(recipeHolder);
+    protected RecipeMap prepare(ResourceManager manager, ProfilerFiller profiler) {
+        SortedMap<ResourceLocation, Recipe<?>> sortedmap = new TreeMap();
+
+        SimpleJsonResourceReloadListener.scanDirectory(manager, Registries.elementsDirPath(Registries.RECIPE), this.registries.createSerializationContext(JsonOps.INSTANCE), Recipe.CODEC, sortedmap);
+        List<RecipeHolder<?>> list = new ArrayList(sortedmap.size());
+
+        sortedmap.forEach((minecraftkey, irecipe) -> {
+            ResourceKey<Recipe<?>> resourcekey = ResourceKey.create(Registries.RECIPE, minecraftkey);
+            RecipeHolder<?> recipeholder = new RecipeHolder<>(resourcekey, irecipe);
+
+            list.add(recipeholder);
         });
         return RecipeMap.create(list);
     }
 
-    @Override
     protected void apply(RecipeMap prepared, ResourceManager manager, ProfilerFiller profiler) {
         this.recipes = prepared;
-        LOGGER.info("Loaded {} recipes", prepared.values().size());
+        RecipeManager.LOGGER.info("Loaded {} recipes", prepared.values().size());
+    }
+
+    // CraftBukkit start
+    public void addRecipe(RecipeHolder<?> irecipe) {
+        org.spigotmc.AsyncCatcher.catchOp("Recipe Add"); // Spigot
+        this.recipes.addRecipe(irecipe);
+        this.finalizeRecipeLoading();
+    }
+
+    private FeatureFlagSet featureflagset;
+
+    public void finalizeRecipeLoading() {
+        if (this.featureflagset != null) {
+            this.finalizeRecipeLoading(this.featureflagset);
+
+            MinecraftServer.getServer().getPlayerList().reloadRecipes();
+        }
     }
 
     public void finalizeRecipeLoading(FeatureFlagSet features) {
-        List<SelectableRecipe.SingleInputEntry<StonecutterRecipe>> list = new ArrayList<>();
-        List<RecipeManager.IngredientCollector> list2 = RECIPE_PROPERTY_SETS.entrySet()
-            .stream()
-            .map(entry -> new RecipeManager.IngredientCollector(entry.getKey(), entry.getValue()))
-            .toList();
-        this.recipes
-            .values()
-            .forEach(
-                recipe -> {
-                    Recipe<?> recipe2 = recipe.value();
-                    if (!recipe2.isSpecial() && recipe2.placementInfo().isImpossibleToPlace()) {
-                        LOGGER.warn("Recipe {} can't be placed due to empty ingredients and will be ignored", recipe.id().location());
-                    } else {
-                        list2.forEach(builder -> builder.accept(recipe2));
-                        if (recipe2 instanceof StonecutterRecipe stonecutterRecipe
-                            && isIngredientEnabled(features, stonecutterRecipe.input())
-                            && stonecutterRecipe.resultDisplay().isEnabled(features)) {
-                            list.add(
-                                new SelectableRecipe.SingleInputEntry<>(
-                                    stonecutterRecipe.input(),
-                                    new SelectableRecipe<>(stonecutterRecipe.resultDisplay(), Optional.of((RecipeHolder<StonecutterRecipe>)recipe))
-                                )
-                            );
-                        }
+        this.featureflagset = features;
+        // CraftBukkit end
+        List<SelectableRecipe.SingleInputEntry<StonecutterRecipe>> list = new ArrayList();
+        List<RecipeManager.IngredientCollector> list1 = RecipeManager.RECIPE_PROPERTY_SETS.entrySet().stream().map((entry) -> {
+            return new RecipeManager.IngredientCollector((ResourceKey) entry.getKey(), (RecipeManager.IngredientExtractor) entry.getValue());
+        }).toList();
+
+        this.recipes.values().forEach((recipeholder) -> {
+            Recipe<?> irecipe = recipeholder.value();
+
+            if (!irecipe.isSpecial() && irecipe.placementInfo().isImpossibleToPlace()) {
+                RecipeManager.LOGGER.warn("Recipe {} can't be placed due to empty ingredients and will be ignored", recipeholder.id().location());
+            } else {
+                list1.forEach((craftingmanager_b) -> {
+                    craftingmanager_b.accept(irecipe);
+                });
+                if (irecipe instanceof StonecutterRecipe) {
+                    StonecutterRecipe recipestonecutting = (StonecutterRecipe) irecipe;
+
+                    if (RecipeManager.isIngredientEnabled(features, recipestonecutting.input()) && recipestonecutting.resultDisplay().isEnabled(features)) {
+                        list.add(new SelectableRecipe.SingleInputEntry<StonecutterRecipe>(recipestonecutting.input(), new SelectableRecipe<>(recipestonecutting.resultDisplay(), Optional.of((RecipeHolder<StonecutterRecipe>) recipeholder)))); // CraftBukkit - decompile error
                     }
                 }
-            );
-        this.propertySets = list2.stream().collect(Collectors.toUnmodifiableMap(builder -> builder.key, builder -> builder.asPropertySet(features)));
+
+            }
+        });
+        this.propertySets = (Map) list1.stream().collect(Collectors.toUnmodifiableMap((craftingmanager_b) -> {
+            return craftingmanager_b.key;
+        }, (craftingmanager_b) -> {
+            return craftingmanager_b.asPropertySet(features);
+        }));
         this.stonecutterRecipes = new SelectableRecipe.SingleInputSet<>(list);
-        this.allDisplays = unpackRecipeInfo(this.recipes.values(), features);
-        this.recipeToDisplay = this.allDisplays
-            .stream()
-            .collect(Collectors.groupingBy(recipe -> recipe.parent.id(), IdentityHashMap::new, Collectors.toList()));
+        this.allDisplays = RecipeManager.unpackRecipeInfo(this.recipes.values(), features);
+        this.recipeToDisplay = (Map) this.allDisplays.stream().collect(Collectors.groupingBy((craftingmanager_d) -> {
+            return craftingmanager_d.parent.id();
+        }, IdentityHashMap::new, Collectors.toList()));
     }
 
     static List<Ingredient> filterDisabled(FeatureFlagSet features, List<Ingredient> ingredients) {
-        ingredients.removeIf(ingredient -> !isIngredientEnabled(features, ingredient));
+        ingredients.removeIf((recipeitemstack) -> {
+            return !RecipeManager.isIngredientEnabled(features, recipeitemstack);
+        });
         return ingredients;
     }
 
     private static boolean isIngredientEnabled(FeatureFlagSet features, Ingredient ingredient) {
-        return ingredient.items().stream().allMatch(entry -> entry.value().isEnabled(features));
+        return ingredient.items().stream().allMatch((holder) -> {
+            return ((Item) holder.value()).isEnabled(features);
+        });
     }
 
-    public <I extends RecipeInput, T extends Recipe<I>> Optional<RecipeHolder<T>> getRecipeFor(
-        RecipeType<T> type, I input, Level world, @Nullable ResourceKey<Recipe<?>> recipe
-    ) {
-        RecipeHolder<T> recipeHolder = recipe != null ? this.byKeyTyped(type, recipe) : null;
-        return this.getRecipeFor(type, input, world, recipeHolder);
+    public <I extends RecipeInput, T extends Recipe<I>> Optional<RecipeHolder<T>> getRecipeFor(RecipeType<T> type, I input, Level world, @Nullable ResourceKey<Recipe<?>> recipe) {
+        RecipeHolder<T> recipeholder = recipe != null ? this.byKeyTyped(type, recipe) : null;
+
+        return this.getRecipeFor(type, input, world, recipeholder);
     }
 
-    public <I extends RecipeInput, T extends Recipe<I>> Optional<RecipeHolder<T>> getRecipeFor(
-        RecipeType<T> type, I input, Level world, @Nullable RecipeHolder<T> recipe
-    ) {
+    public <I extends RecipeInput, T extends Recipe<I>> Optional<RecipeHolder<T>> getRecipeFor(RecipeType<T> type, I input, Level world, @Nullable RecipeHolder<T> recipe) {
         return recipe != null && recipe.value().matches(input, world) ? Optional.of(recipe) : this.getRecipeFor(type, input, world);
     }
 
     public <I extends RecipeInput, T extends Recipe<I>> Optional<RecipeHolder<T>> getRecipeFor(RecipeType<T> type, I input, Level world) {
-        return this.recipes.getRecipesFor(type, input, world).findFirst();
+        // CraftBukkit start
+        List<RecipeHolder<T>> list = this.recipes.getRecipesFor(type, input, world).toList();
+        return (list.isEmpty()) ? Optional.empty() : Optional.of(list.getLast()); // CraftBukkit - SPIGOT-4638: last recipe gets priority
+        // CraftBukkit end
     }
 
     public Optional<RecipeHolder<?>> byKey(ResourceKey<Recipe<?>> key) {
@@ -157,8 +206,9 @@
 
     @Nullable
     private <T extends Recipe<?>> RecipeHolder<T> byKeyTyped(RecipeType<T> type, ResourceKey<Recipe<?>> key) {
-        RecipeHolder<?> recipeHolder = this.recipes.byKey(key);
-        return (RecipeHolder<T>)(recipeHolder != null && recipeHolder.value().getType().equals(type) ? recipeHolder : null);
+        RecipeHolder<?> recipeholder = this.recipes.byKey(key);
+
+        return recipeholder != null && recipeholder.value().getType().equals(type) ? (RecipeHolder) recipeholder : null; // CraftBukkit - decompile error
     }
 
     public Map<ResourceKey<RecipePropertySet>, RecipePropertySet> getSynchronizedItemProperties() {
@@ -171,7 +221,7 @@
 
     @Override
     public RecipePropertySet propertySet(ResourceKey<RecipePropertySet> key) {
-        return this.propertySets.getOrDefault(key, RecipePropertySet.EMPTY);
+        return (RecipePropertySet) this.propertySets.getOrDefault(key, RecipePropertySet.EMPTY);
     }
 
     @Override
@@ -185,35 +235,58 @@
 
     @Nullable
     public RecipeManager.ServerDisplayInfo getRecipeFromDisplay(RecipeDisplayId id) {
-        return this.allDisplays.get(id.index());
+        return (RecipeManager.ServerDisplayInfo) this.allDisplays.get(id.index());
     }
 
     public void listDisplaysForRecipe(ResourceKey<Recipe<?>> key, Consumer<RecipeDisplayEntry> action) {
-        List<RecipeManager.ServerDisplayInfo> list = this.recipeToDisplay.get(key);
+        List<RecipeManager.ServerDisplayInfo> list = (List) this.recipeToDisplay.get(key);
+
         if (list != null) {
-            list.forEach(recipe -> action.accept(recipe.display));
+            list.forEach((craftingmanager_d) -> {
+                action.accept(craftingmanager_d.display);
+            });
         }
+
     }
 
     @VisibleForTesting
     protected static RecipeHolder<?> fromJson(ResourceKey<Recipe<?>> key, JsonObject json, HolderLookup.Provider registries) {
-        Recipe<?> recipe = Recipe.CODEC.parse(registries.createSerializationContext(JsonOps.INSTANCE), json).getOrThrow(JsonParseException::new);
-        return new RecipeHolder<>(key, recipe);
+        Recipe<?> irecipe = (Recipe) Recipe.CODEC.parse(registries.createSerializationContext(JsonOps.INSTANCE), json).getOrThrow(JsonParseException::new);
+
+        return new RecipeHolder<>(key, irecipe);
     }
 
-    public static <I extends RecipeInput, T extends Recipe<I>> RecipeManager.CachedCheck<I, T> createCheck(RecipeType<T> type) {
+    // CraftBukkit start
+    public boolean removeRecipe(ResourceKey<Recipe<?>> mcKey) {
+        boolean removed = this.recipes.removeRecipe((ResourceKey<Recipe<RecipeInput>>) (ResourceKey) mcKey); // Paper - generic fix
+        if (removed) {
+            this.finalizeRecipeLoading();
+        }
+
+        return removed;
+    }
+
+    public void clearRecipes() {
+        this.recipes = RecipeMap.create(Collections.emptyList());
+        this.finalizeRecipeLoading();
+    }
+    // CraftBukkit end
+
+    public static <I extends RecipeInput, T extends Recipe<I>> RecipeManager.CachedCheck<I, T> createCheck(final RecipeType<T> type) {
         return new RecipeManager.CachedCheck<I, T>() {
             @Nullable
             private ResourceKey<Recipe<?>> lastRecipe;
 
             @Override
             public Optional<RecipeHolder<T>> getRecipeFor(I input, ServerLevel world) {
-                RecipeManager recipeManager = world.recipeAccess();
-                Optional<RecipeHolder<T>> optional = recipeManager.getRecipeFor(type, input, world, this.lastRecipe);
+                RecipeManager craftingmanager = world.recipeAccess();
+                Optional<RecipeHolder<T>> optional = craftingmanager.getRecipeFor(type, input, world, this.lastRecipe);
+
                 if (optional.isPresent()) {
-                    RecipeHolder<T> recipeHolder = optional.get();
-                    this.lastRecipe = recipeHolder.id();
-                    return Optional.of(recipeHolder);
+                    RecipeHolder<T> recipeholder = (RecipeHolder) optional.get();
+
+                    this.lastRecipe = recipeholder.id();
+                    return Optional.of(recipeholder);
                 } else {
                     return Optional.empty();
                 }
@@ -222,33 +295,42 @@
     }
 
     private static List<RecipeManager.ServerDisplayInfo> unpackRecipeInfo(Iterable<RecipeHolder<?>> recipes, FeatureFlagSet enabledFeatures) {
-        List<RecipeManager.ServerDisplayInfo> list = new ArrayList<>();
-        Object2IntMap<String> object2IntMap = new Object2IntOpenHashMap<>();
+        List<RecipeManager.ServerDisplayInfo> list = new ArrayList();
+        Object2IntMap<String> object2intmap = new Object2IntOpenHashMap();
+        Iterator iterator = recipes.iterator();
 
-        for (RecipeHolder<?> recipeHolder : recipes) {
-            Recipe<?> recipe = recipeHolder.value();
-            OptionalInt optionalInt;
-            if (recipe.group().isEmpty()) {
-                optionalInt = OptionalInt.empty();
+        while (iterator.hasNext()) {
+            RecipeHolder<?> recipeholder = (RecipeHolder) iterator.next();
+            Recipe<?> irecipe = recipeholder.value();
+            OptionalInt optionalint;
+
+            if (irecipe.group().isEmpty()) {
+                optionalint = OptionalInt.empty();
             } else {
-                optionalInt = OptionalInt.of(object2IntMap.computeIfAbsent(recipe.group(), group -> object2IntMap.size()));
+                optionalint = OptionalInt.of(object2intmap.computeIfAbsent(irecipe.group(), (object) -> {
+                    return object2intmap.size();
+                }));
             }
 
-            Optional<List<Ingredient>> optional;
-            if (recipe.isSpecial()) {
+            Optional optional;
+
+            if (irecipe.isSpecial()) {
                 optional = Optional.empty();
             } else {
-                optional = Optional.of(recipe.placementInfo().ingredients());
+                optional = Optional.of(irecipe.placementInfo().ingredients());
             }
 
-            for (RecipeDisplay recipeDisplay : recipe.display()) {
-                if (recipeDisplay.isEnabled(enabledFeatures)) {
+            Iterator iterator1 = irecipe.display().iterator();
+
+            while (iterator1.hasNext()) {
+                RecipeDisplay recipedisplay = (RecipeDisplay) iterator1.next();
+
+                if (recipedisplay.isEnabled(enabledFeatures)) {
                     int i = list.size();
-                    RecipeDisplayId recipeDisplayId = new RecipeDisplayId(i);
-                    RecipeDisplayEntry recipeDisplayEntry = new RecipeDisplayEntry(
-                        recipeDisplayId, recipeDisplay, optionalInt, recipe.recipeBookCategory(), optional
-                    );
-                    list.add(new RecipeManager.ServerDisplayInfo(recipeDisplayEntry, recipeHolder));
+                    RecipeDisplayId recipedisplayid = new RecipeDisplayId(i);
+                    RecipeDisplayEntry recipedisplayentry = new RecipeDisplayEntry(recipedisplayid, recipedisplay, optionalint, irecipe.recipeBookCategory(), optional);
+
+                    list.add(new RecipeManager.ServerDisplayInfo(recipedisplayentry, recipeholder));
                 }
             }
         }
@@ -257,28 +339,46 @@
     }
 
     private static RecipeManager.IngredientExtractor forSingleInput(RecipeType<? extends SingleItemRecipe> expectedType) {
-        return recipe -> recipe.getType() == expectedType && recipe instanceof SingleItemRecipe singleItemRecipe
-                ? Optional.of(singleItemRecipe.input())
-                : Optional.empty();
+        return (irecipe) -> {
+            Optional optional;
+
+            if (irecipe.getType() == expectedType && irecipe instanceof SingleItemRecipe recipesingleitem) {
+                optional = Optional.of(recipesingleitem.input());
+            } else {
+                optional = Optional.empty();
+            }
+
+            return optional;
+        };
     }
 
-    public interface CachedCheck<I extends RecipeInput, T extends Recipe<I>> {
-        Optional<RecipeHolder<T>> getRecipeFor(I input, ServerLevel world);
+    public static record ServerDisplayInfo(RecipeDisplayEntry display, RecipeHolder<?> parent) {
+
+    }
+
+    @FunctionalInterface
+    public interface IngredientExtractor {
+
+        Optional<Ingredient> apply(Recipe<?> recipe);
     }
 
     public static class IngredientCollector implements Consumer<Recipe<?>> {
+
         final ResourceKey<RecipePropertySet> key;
         private final RecipeManager.IngredientExtractor extractor;
-        private final List<Ingredient> ingredients = new ArrayList<>();
+        private final List<Ingredient> ingredients = new ArrayList();
 
         protected IngredientCollector(ResourceKey<RecipePropertySet> propertySetKey, RecipeManager.IngredientExtractor ingredientGetter) {
             this.key = propertySetKey;
             this.extractor = ingredientGetter;
         }
 
-        @Override
-        public void accept(Recipe<?> recipe) {
-            this.extractor.apply(recipe).ifPresent(this.ingredients::add);
+        public void accept(Recipe<?> irecipe) {
+            Optional optional = this.extractor.apply(irecipe);
+            List list = this.ingredients;
+
+            Objects.requireNonNull(this.ingredients);
+            optional.ifPresent(list::add);
         }
 
         public RecipePropertySet asPropertySet(FeatureFlagSet enabledFeatures) {
@@ -286,11 +386,8 @@
         }
     }
 
-    @FunctionalInterface
-    public interface IngredientExtractor {
-        Optional<Ingredient> apply(Recipe<?> recipe);
-    }
+    public interface CachedCheck<I extends RecipeInput, T extends Recipe<I>> {
 
-    public static record ServerDisplayInfo(RecipeDisplayEntry display, RecipeHolder<?> parent) {
+        Optional<RecipeHolder<T>> getRecipeFor(I input, ServerLevel world);
     }
 }
