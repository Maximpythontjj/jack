--- a/net/minecraft/world/level/chunk/LevelChunkSection.java
+++ b/net/minecraft/world/level/chunk/LevelChunkSection.java
@@ -13,16 +13,41 @@
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.material.FluidState;
 
-public class LevelChunkSection {
+public class LevelChunkSection implements ca.spottedleaf.moonrise.patches.block_counting.BlockCountingChunkSection { // Paper - block counting
+
     public static final int SECTION_WIDTH = 16;
     public static final int SECTION_HEIGHT = 16;
     public static final int SECTION_SIZE = 4096;
     public static final int BIOME_CONTAINER_BITS = 2;
-    private short nonEmptyBlockCount;
+    short nonEmptyBlockCount; // Paper - package private
     private short tickingBlockCount;
     private short tickingFluidCount;
     public final PalettedContainer<BlockState> states;
-    private PalettedContainerRO<Holder<Biome>> biomes;
+    private PalettedContainer<Holder<Biome>> biomes; // CraftBukkit - read/write
+
+    // Paper start - block counting
+    private static final it.unimi.dsi.fastutil.shorts.ShortArrayList FULL_LIST = new it.unimi.dsi.fastutil.shorts.ShortArrayList(16*16*16);
+    static {
+        for (short i = 0; i < (16*16*16); ++i) {
+            FULL_LIST.add(i);
+        }
+    }
+
+    private boolean isClient;
+    private static final short CLIENT_FORCED_SPECIAL_COLLIDING_BLOCKS = (short)9999;
+    private short specialCollidingBlocks;
+    private final ca.spottedleaf.moonrise.common.list.ShortList tickingBlocks = new ca.spottedleaf.moonrise.common.list.ShortList();
+
+    @Override
+    public final boolean moonrise$hasSpecialCollidingBlocks() {
+        return this.specialCollidingBlocks != 0;
+    }
+
+    @Override
+    public final ca.spottedleaf.moonrise.common.list.ShortList moonrise$getTickingBlockList() {
+        return this.tickingBlocks;
+    }
+    // Paper end - block counting
 
     private LevelChunkSection(LevelChunkSection section) {
         this.nonEmptyBlockCount = section.nonEmptyBlockCount;
@@ -32,23 +57,26 @@
         this.biomes = section.biomes.copy();
     }
 
-    public LevelChunkSection(PalettedContainer<BlockState> blockStateContainer, PalettedContainerRO<Holder<Biome>> biomeContainer) {
-        this.states = blockStateContainer;
-        this.biomes = biomeContainer;
+    public LevelChunkSection(PalettedContainer<BlockState> datapaletteblock, PalettedContainer<Holder<Biome>> palettedcontainerro) { // CraftBukkit - read/write
+        this.states = datapaletteblock;
+        this.biomes = palettedcontainerro;
         this.recalcBlockCounts();
     }
 
-    public LevelChunkSection(Registry<Biome> biomeRegistry) {
-        this.states = new PalettedContainer<>(Block.BLOCK_STATE_REGISTRY, Blocks.AIR.defaultBlockState(), PalettedContainer.Strategy.SECTION_STATES);
-        this.biomes = new PalettedContainer<>(biomeRegistry.asHolderIdMap(), biomeRegistry.getOrThrow(Biomes.PLAINS), PalettedContainer.Strategy.SECTION_BIOMES);
+    // Paper start - Anti-Xray - Add parameters
+    @Deprecated @io.papermc.paper.annotation.DoNotUse public LevelChunkSection(Registry<Biome> biomeRegistry) { this(biomeRegistry, null, null, 0); }
+    public LevelChunkSection(Registry<Biome> biomeRegistry, net.minecraft.world.level.Level level, net.minecraft.world.level.ChunkPos chunkPos, int chunkSectionY) {
+    // Paper end
+        this.states = new PalettedContainer<>(Block.BLOCK_STATE_REGISTRY, Blocks.AIR.defaultBlockState(), PalettedContainer.Strategy.SECTION_STATES, level == null || level.chunkPacketBlockController == null ? null : level.chunkPacketBlockController.getPresetBlockStates(level, chunkPos, chunkSectionY)); // Paper - Anti-Xray - Add preset block states
+        this.biomes = new PalettedContainer<>(biomeRegistry.asHolderIdMap(), biomeRegistry.getOrThrow(Biomes.PLAINS), PalettedContainer.Strategy.SECTION_BIOMES, null); // Paper - Anti-Xray - Add preset biomes
     }
 
     public BlockState getBlockState(int x, int y, int z) {
-        return this.states.get(x, y, z);
+        return (BlockState) this.states.get(x, y, z);
     }
 
     public FluidState getFluidState(int x, int y, int z) {
-        return this.states.get(x, y, z).getFluidState();
+        return this.states.get(x, y, z).getFluidState(); // Paper - Perf: Optimise Chunk#getFluid; diff on change - we expect this to be effectively just getType(x, y, z).getFluid(). If this changes we need to check other patches that use IBlockData#getFluid.
     }
 
     public void acquire() {
@@ -63,39 +91,82 @@
         return this.setBlockState(x, y, z, state, true);
     }
 
+    // Paper start - block counting
+    private void updateBlockCallback(final int x, final int y, final int z, final BlockState newState,
+                                     final BlockState oldState) {
+        if (oldState == newState) {
+            return;
+        }
+
+        if (this.isClient) {
+            if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.isSpecialCollidingBlock(newState)) {
+                this.specialCollidingBlocks = CLIENT_FORCED_SPECIAL_COLLIDING_BLOCKS;
+            }
+            return;
+        }
+
+        final boolean isSpecialOld = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.isSpecialCollidingBlock(oldState);
+        final boolean isSpecialNew = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.isSpecialCollidingBlock(newState);
+        if (isSpecialOld != isSpecialNew) {
+            if (isSpecialOld) {
+                --this.specialCollidingBlocks;
+            } else {
+                ++this.specialCollidingBlocks;
+            }
+        }
+
+        final boolean oldTicking = oldState.isRandomlyTicking();
+        final boolean newTicking = newState.isRandomlyTicking();
+        if (oldTicking != newTicking) {
+            final ca.spottedleaf.moonrise.common.list.ShortList tickingBlocks = this.tickingBlocks;
+            final short position = (short)(x | (z << 4) | (y << (4+4)));
+
+            if (oldTicking) {
+                tickingBlocks.remove(position);
+            } else {
+                tickingBlocks.add(position);
+            }
+        }
+    }
+    // Paper end - block counting
+
     public BlockState setBlockState(int x, int y, int z, BlockState state, boolean lock) {
-        BlockState blockState;
+        BlockState iblockdata1;
+
         if (lock) {
-            blockState = this.states.getAndSet(x, y, z, state);
+            iblockdata1 = (BlockState) this.states.getAndSet(x, y, z, state);
         } else {
-            blockState = this.states.getAndSetUnchecked(x, y, z, state);
+            iblockdata1 = (BlockState) this.states.getAndSetUnchecked(x, y, z, state);
         }
 
-        FluidState fluidState = blockState.getFluidState();
-        FluidState fluidState2 = state.getFluidState();
-        if (!blockState.isAir()) {
-            this.nonEmptyBlockCount--;
-            if (blockState.isRandomlyTicking()) {
-                this.tickingBlockCount--;
+        FluidState fluid = iblockdata1.getFluidState();
+        FluidState fluid1 = state.getFluidState();
+
+        if (!iblockdata1.isAir()) {
+            --this.nonEmptyBlockCount;
+            if (iblockdata1.isRandomlyTicking()) {
+                --this.tickingBlockCount;
             }
         }
 
-        if (!fluidState.isEmpty()) {
-            this.tickingFluidCount--;
+        if (!!fluid.isRandomlyTicking()) { // Paper - block counting
+            --this.tickingFluidCount;
         }
 
         if (!state.isAir()) {
-            this.nonEmptyBlockCount++;
+            ++this.nonEmptyBlockCount;
             if (state.isRandomlyTicking()) {
-                this.tickingBlockCount++;
+                ++this.tickingBlockCount;
             }
         }
 
-        if (!fluidState2.isEmpty()) {
-            this.tickingFluidCount++;
+        if (!!fluid1.isRandomlyTicking()) { // Paper - block counting
+            ++this.tickingFluidCount;
         }
 
-        return blockState;
+        this.updateBlockCallback(x, y, z, state, iblockdata1); // Paper - block counting
+
+        return iblockdata1;
     }
 
     public boolean hasOnlyAir() {
@@ -115,35 +186,70 @@
     }
 
     public void recalcBlockCounts() {
-        class BlockCounter implements PalettedContainer.CountConsumer<BlockState> {
-            public int nonEmptyBlockCount;
-            public int tickingBlockCount;
-            public int tickingFluidCount;
+        // Paper start - block counting
+        // reset, then recalculate
+        this.nonEmptyBlockCount = (short)0;
+        this.tickingBlockCount = (short)0;
+        this.tickingFluidCount = (short)0;
+        this.specialCollidingBlocks = (short)0;
+        this.tickingBlocks.clear();
 
-            @Override
-            public void accept(BlockState blockState, int i) {
-                FluidState fluidState = blockState.getFluidState();
-                if (!blockState.isAir()) {
-                    this.nonEmptyBlockCount += i;
-                    if (blockState.isRandomlyTicking()) {
-                        this.tickingBlockCount += i;
+        if (this.maybeHas((final BlockState state) -> !state.isAir())) {
+            final PalettedContainer.Data<BlockState> data = this.states.data;
+            final Palette<BlockState> palette = data.palette();
+            final int paletteSize = palette.getSize();
+            final net.minecraft.util.BitStorage storage = data.storage();
+
+            final it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap<it.unimi.dsi.fastutil.shorts.ShortArrayList> counts;
+            if (paletteSize == 1) {
+                counts = new it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap<>(1);
+                counts.put(0, FULL_LIST);
+            } else {
+                counts = ((ca.spottedleaf.moonrise.patches.block_counting.BlockCountingBitStorage)storage).moonrise$countEntries();
+            }
+
+            for (final java.util.Iterator<it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<it.unimi.dsi.fastutil.shorts.ShortArrayList>> iterator = counts.int2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+                final it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<it.unimi.dsi.fastutil.shorts.ShortArrayList> entry = iterator.next();
+                final int paletteIdx = entry.getIntKey();
+                final it.unimi.dsi.fastutil.shorts.ShortArrayList coordinates = entry.getValue();
+                final int paletteCount = coordinates.size();
+
+                final BlockState state = palette.valueFor(paletteIdx);
+
+                if (state.isAir()) {
+                    continue;
+                }
+
+                if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.isSpecialCollidingBlock(state)) {
+                    this.specialCollidingBlocks += (short)paletteCount;
+                }
+                this.nonEmptyBlockCount += (short)paletteCount;
+                if (state.isRandomlyTicking()) {
+                    this.tickingBlockCount += (short)paletteCount;
+                    final short[] raw = coordinates.elements();
+                    final int rawLen = raw.length;
+
+                    final ca.spottedleaf.moonrise.common.list.ShortList tickingBlocks = this.tickingBlocks;
+
+                    tickingBlocks.setMinCapacity(Math.min((rawLen + tickingBlocks.size()) * 3 / 2, 16*16*16));
+
+                    java.util.Objects.checkFromToIndex(0, paletteCount, raw.length);
+                    for (int i = 0; i < paletteCount; ++i) {
+                        tickingBlocks.add(raw[i]);
                     }
                 }
 
-                if (!fluidState.isEmpty()) {
-                    this.nonEmptyBlockCount += i;
-                    if (fluidState.isRandomlyTicking()) {
-                        this.tickingFluidCount += i;
+                final FluidState fluid = state.getFluidState();
+
+                if (!fluid.isEmpty()) {
+                    //this.nonEmptyBlockCount += count; // fix vanilla bug: make non-empty block count correct
+                    if (fluid.isRandomlyTicking()) {
+                        this.tickingFluidCount += (short)paletteCount;
                     }
                 }
             }
         }
-
-        BlockCounter lv = new BlockCounter();
-        this.states.count(lv);
-        this.nonEmptyBlockCount = (short)lv.nonEmptyBlockCount;
-        this.tickingBlockCount = (short)lv.tickingBlockCount;
-        this.tickingFluidCount = (short)lv.tickingFluidCount;
+        // Paper end - block counting
     }
 
     public PalettedContainer<BlockState> getStates() {
@@ -157,21 +263,31 @@
     public void read(FriendlyByteBuf buf) {
         this.nonEmptyBlockCount = buf.readShort();
         this.states.read(buf);
-        PalettedContainer<Holder<Biome>> palettedContainer = this.biomes.recreate();
-        palettedContainer.read(buf);
-        this.biomes = palettedContainer;
+        PalettedContainer<Holder<Biome>> datapaletteblock = this.biomes.recreate();
+
+        datapaletteblock.read(buf);
+        this.biomes = datapaletteblock;
+        // Paper start - block counting
+        this.isClient = true;
+        // force has special colliding blocks to be true
+        this.specialCollidingBlocks = this.nonEmptyBlockCount != (short)0 && this.maybeHas(ca.spottedleaf.moonrise.patches.collisions.CollisionUtil::isSpecialCollidingBlock) ? CLIENT_FORCED_SPECIAL_COLLIDING_BLOCKS : (short)0;
+        // Paper end - block counting
     }
 
     public void readBiomes(FriendlyByteBuf buf) {
-        PalettedContainer<Holder<Biome>> palettedContainer = this.biomes.recreate();
-        palettedContainer.read(buf);
-        this.biomes = palettedContainer;
+        PalettedContainer<Holder<Biome>> datapaletteblock = this.biomes.recreate();
+
+        datapaletteblock.read(buf);
+        this.biomes = datapaletteblock;
     }
 
-    public void write(FriendlyByteBuf buf) {
+    // Paper start - Anti-Xray - Add chunk packet info
+    @Deprecated @io.papermc.paper.annotation.DoNotUse public void write(FriendlyByteBuf buf) { this.write(buf, null, 0); }
+    public void write(FriendlyByteBuf buf, com.destroystokyo.paper.antixray.ChunkPacketInfo<BlockState> chunkPacketInfo, int chunkSectionIndex) {
         buf.writeShort(this.nonEmptyBlockCount);
-        this.states.write(buf);
-        this.biomes.write(buf);
+        this.states.write(buf, chunkPacketInfo, chunkSectionIndex);
+        this.biomes.write(buf, null, chunkSectionIndex);
+        // Paper end
     }
 
     public int getSerializedSize() {
@@ -183,22 +299,28 @@
     }
 
     public Holder<Biome> getNoiseBiome(int x, int y, int z) {
-        return this.biomes.get(x, y, z);
+        return (Holder) this.biomes.get(x, y, z);
     }
 
+    // CraftBukkit start
+    public void setBiome(int i, int j, int k, Holder<Biome> biome) {
+        this.biomes.set(i, j, k, biome);
+    }
+    // CraftBukkit end
+
     public void fillBiomesFromNoise(BiomeResolver biomeSupplier, Climate.Sampler sampler, int x, int y, int z) {
-        PalettedContainer<Holder<Biome>> palettedContainer = this.biomes.recreate();
-        int i = 4;
+        PalettedContainer<Holder<Biome>> datapaletteblock = this.biomes.recreate();
+        boolean flag = true;
 
-        for (int j = 0; j < 4; j++) {
-            for (int k = 0; k < 4; k++) {
-                for (int l = 0; l < 4; l++) {
-                    palettedContainer.getAndSetUnchecked(j, k, l, biomeSupplier.getNoiseBiome(x + j, y + k, z + l, sampler));
+        for (int l = 0; l < 4; ++l) {
+            for (int i1 = 0; i1 < 4; ++i1) {
+                for (int j1 = 0; j1 < 4; ++j1) {
+                    datapaletteblock.getAndSetUnchecked(l, i1, j1, biomeSupplier.getNoiseBiome(x + l, y + i1, z + j1, sampler));
                 }
             }
         }
 
-        this.biomes = palettedContainer;
+        this.biomes = datapaletteblock;
     }
 
     public LevelChunkSection copy() {
