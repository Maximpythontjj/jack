--- a/net/minecraft/core/MappedRegistry.java
+++ b/net/minecraft/core/MappedRegistry.java
@@ -33,11 +33,11 @@
 public class MappedRegistry<T> implements WritableRegistry<T> {
     private final ResourceKey<? extends Registry<T>> key;
     private final ObjectList<Holder.Reference<T>> byId = new ObjectArrayList<>(256);
-    private final Reference2IntMap<T> toId = Util.make(new Reference2IntOpenHashMap<>(), map -> map.defaultReturnValue(-1));
-    private final Map<ResourceLocation, Holder.Reference<T>> byLocation = new HashMap<>();
-    private final Map<ResourceKey<T>, Holder.Reference<T>> byKey = new HashMap<>();
-    private final Map<T, Holder.Reference<T>> byValue = new IdentityHashMap<>();
-    private final Map<ResourceKey<T>, RegistrationInfo> registrationInfos = new IdentityHashMap<>();
+    private final Reference2IntMap<T> toId = Util.make(new Reference2IntOpenHashMap<>(2048), map -> map.defaultReturnValue(-1)); // Paper - Perf: Use bigger expected size to reduce collisions
+    private final Map<ResourceLocation, Holder.Reference<T>> byLocation = new HashMap<>(2048); // Paper - Perf: Use bigger expected size to reduce collisions
+    private final Map<ResourceKey<T>, Holder.Reference<T>> byKey = new HashMap<>(2048); // Paper - Perf: Use bigger expected size to reduce collisions
+    private final Map<T, Holder.Reference<T>> byValue = new IdentityHashMap<>(2048); // Paper - Perf: Use bigger expected size to reduce collisions
+    private final Map<ResourceKey<T>, RegistrationInfo> registrationInfos = new IdentityHashMap<>(2048); // Paper - Perf: Use bigger expected size to reduce collisions
     private Lifecycle registryLifecycle;
     private final Map<TagKey<T>, HolderSet.Named<T>> frozenTags = new IdentityHashMap<>();
     MappedRegistry.TagSet<T> allTags = MappedRegistry.TagSet.unbound();
@@ -50,6 +50,19 @@
         return this.getTags();
     }
 
+    // Paper start - fluid method optimisations
+    private void injectFluidRegister(
+        final ResourceKey<?> resourceKey,
+        final T object
+    ) {
+        if (resourceKey.registryKey() == (Object)net.minecraft.core.registries.Registries.FLUID) {
+            for (final net.minecraft.world.level.material.FluidState possibleState : ((net.minecraft.world.level.material.Fluid)object).getStateDefinition().getPossibleStates()) {
+                ((ca.spottedleaf.moonrise.patches.fluid.FluidFluidState)(Object)possibleState).moonrise$initCaches();
+            }
+        }
+    }
+    // Paper end - fluid method optimisations
+
     public MappedRegistry(ResourceKey<? extends Registry<T>> key, Lifecycle lifecycle) {
         this(key, lifecycle, false);
     }
@@ -114,6 +127,7 @@
             this.toId.put(value, i);
             this.registrationInfos.put(key, info);
             this.registryLifecycle = this.registryLifecycle.add(info.lifecycle());
+            this.injectFluidRegister(key, value); // Paper - fluid method optimisations
             return reference;
         }
     }
@@ -509,4 +523,12 @@
 
         Stream<HolderSet.Named<T>> getTags();
     }
+    // Paper start
+    // used to clear intrusive holders from GameEvent, Item, Block, EntityType, and Fluid from unused instances of those types
+    public void clearIntrusiveHolder(final T instance) {
+        if (this.unregisteredIntrusiveHolders != null) {
+            this.unregisteredIntrusiveHolders.remove(instance);
+        }
+    }
+    // Paper end
 }
