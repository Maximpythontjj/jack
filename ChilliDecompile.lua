--[[
    ЧАСТИЧНАЯ ДЕОБФУСКАЦИЯ: Chilli.lua
    
    ВАЖНО: Этот файл был защищен Luraph Obfuscator v14.4.1
    Полная деобфускация невозможна из-за:
    - Виртуализации инструкций
    - Шифрования строк и констант
    - Многослойной обфускации управления потоком
    - Защиты от отладки и анализа
    
    Ниже представлена ЧАСТИЧНО восстановленная структура
    на основе анализа обфусцированного кода.
]]--

-- ============================================================
-- АНАЛИЗ СТРУКТУРЫ
-- ============================================================

--[[
    Обфусцированный скрипт возвращает таблицу с множеством функций.
    Основные обнаруженные ключи функций:
    
    - sU, s7, jU, xU - вероятно функции для работы со строками
    - hU - string.unpack (видно в коде)
    - Z, KU, c, w, S, T, O, Q7, Y7 - утилитарные функции
    - I, R7, O7, z7, t7 - операции с таблицами
    - d - table.move (видно в коде)
    - различные функции с суффиксом U (aU, bU, cU и т.д.)
]]--

-- ============================================================
-- КОНСТАНТЫ И НАСТРОЙКИ
-- ============================================================

-- Массив констант U (обнаружен в коде)
local U = {
    27543,          -- U[1]
    701489484,      -- U[2]
    3695534224,     -- U[3]
    184711557,      -- U[4]
    2834437779,     -- U[5]
    1993868778,     -- U[6]
    3076466975,     -- U[7]
    483213186,      -- U[8]
    2931768424      -- U[9]
}

-- ============================================================
-- БИТОВЫЕ ОПЕРАЦИИ (ВИДИМЫЕ ССЫЛКИ)
-- ============================================================

local bit32_operations = {
    lshift = bit32.lshift,      -- Побитовый сдвиг влево
    rshift = bit32.rshift,      -- Побитовый сдвиг вправо
    band = bit32.band,          -- Побитовое И
    bor = bit32.bor,            -- Побитовое ИЛИ
    bxor = bit32.bxor,          -- Побитовое исключающее ИЛИ
    bnot = bit32.bnot,          -- Побитовая инверсия
    lrotate = bit32.lrotate,    -- Циклический сдвиг влево
    rrotate = bit32.rrotate,    -- Циклический сдвиг вправо
    countlz = bit32.countlz,    -- Подсчет нулей слева
    countrz = bit32.countrz     -- Подсчет нулей справа
}

-- ============================================================
-- СТРОКОВЫЕ ОПЕРАЦИИ (ВИДИМЫЕ ССЫЛКИ)
-- ============================================================

local string_operations = {
    unpack = string.unpack,     -- Распаковка бинарных данных
    pack = string.pack,         -- Упаковка бинарных данных
    char = string.char,         -- Создание строки из кодов символов
    byte = string.byte,         -- Получение кода символа
    sub = string.sub,           -- Подстрока
    gsub = string.gsub,         -- Замена подстрок
    match = string.match        -- Поиск по шаблону
}

-- ============================================================
-- ОПЕРАЦИИ С ТАБЛИЦАМИ (ВИДИМЫЕ ССЫЛКИ)
-- ============================================================

local table_operations = {
    move = table.move           -- Перемещение элементов таблицы
}

-- ============================================================
-- СИСТЕМНЫЕ ФУНКЦИИ (ВИДИМЫЕ ССЫЛКИ)
-- ============================================================

local system_functions = {
    type = type,                -- Определение типа
    tostring = tostring,        -- Преобразование в строку
    select = select,            -- Выбор аргументов
    unpack = unpack,            -- Распаковка таблицы
    pcall = pcall,              -- Защищенный вызов
    setfenv = setfenv,          -- Установка окружения (Lua 5.1)
    getfenv = getfenv,          -- Получение окружения (Lua 5.1)
    setmetatable = setmetatable,-- Установка метатаблицы
    error = error,              -- Генерация ошибки
    coroutine_yield = coroutine.yield,  -- Передача управления
    coroutine_wrap = coroutine.wrap     -- Создание корутины
}

-- ============================================================
-- ОБНАРУЖЕННЫЕ ПАТТЕРНЫ
-- ============================================================

--[[
    ПАТТЕРН 1: Расшифровка строк
    В коде присутствует сложная система расшифровки строк через:
    - Base64-подобное кодирование
    - Множественные слои XOR
    - Динамическая генерация ключей
    
    Зашифрованная строка из кода:
    "LPH&``W;8nGiOhzaoDDAz5Z\#.6WX:a<rm5@#%;RoATDlo#'49pBlJ/q!`_Th..."
    
    Функция расшифровки использует таблицу подстановки символов.
]]--

-- ПАТТЕРН 2: Виртуальная машина
--[[
    Код содержит реализацию виртуальной машины Lua со следующими компонентами:
    
    1. Регистры (x) - массив для хранения значений
    2. Стек (v) - указатель на вершину стека
    3. Инструкции (A) - массив байткода
    4. Константы (r) - таблица констант
    5. Upvalues (q) - таблица внешних переменных
    6. Счетчик инструкций (K)
    
    Обнаружено ~104 опкода (от 0 до 103)
]]--

-- ПАТТЕРН 3: Опкоды виртуальной машины
local OPCODES = {
    -- Некоторые определенные опкоды:
    [0] = "RETURN_TRUE_2",      -- Возврат true с 2 значениями
    [1] = "RETURN_TRUE_0",      -- Возврат true с 0 значений  
    [2] = "ASSIGN_SUB",         -- x[t[K]] = x[Z[K]] - x[F[K]]
    [3] = "RETURN_TRUE_1",      -- Возврат true с 1 значением
    [4] = "RETURN_VOID",        -- Пустой возврат
    [5] = "ASSIGN_VALUE",       -- x[Z[K]] = F
    [6] = "ASSIGN_CONST",       -- x[F[K]] = Z
    [7] = "RETURN_FALSE",       -- Возврат false
    [8] = "ASSIGN_UPVAL",       -- x[F[K]] = upvalue[r[K]]
    [9] = "LOOP_INIT",          -- Инициализация цикла
    [10] = "ASSIGN_GLOBAL",     -- x[F[K]] = _ENV[r[K]]
    [11] = "MOVE",              -- x[Z[K]] = x[t[K]]
    [12] = "JUMP_IF_TRUE",      -- if m then K = F[K] end
    [13] = "CALL_VOID",         -- Вызов без возврата
    [14] = "JMP_IF_NOT",        -- if not x[t[K]] then else K = F[K] end
    [15] = "ADD",               -- x[F[K]] = x[t[K]] + x[Z[K]]
    -- ... еще ~90 опкодов
    
    [26] = "LOADNIL",           -- x[F[K]] = nil
    [27] = "LENGTH",            -- x[F[K]] = #x[Z[K]]
    [28] = "SETTABLE_IDX",      -- x[Z[K]][x[t[K]]] = h[K]
    [29] = "CLOSURE",           -- Создание замыкания
    [30] = "LOADK",             -- Загрузка константы
    [31] = "GETTABLE",          -- x[Z[K]] = x[F[K]][x[t[K]]]
    
    [51] = "CALL_1_1",          -- Вызов с 1 аргументом, 1 результат
    [53] = "CALL_N_1",          -- Вызов с N аргументами, 1 результат
    [54] = "NEWARRAY",          -- x[t[K]] = {}
    [55] = "SETLIST",           -- Установка элементов массива
    
    [65] = "GETTABUP_CALL",     -- Получение из таблицы и вызов
    [77] = "MUL",               -- Умножение
    [81] = "DIV",               -- Деление
    [83] = "MUL_CONST",         -- Умножение на константу
    [89] = "FORLOOP",           -- Тело цикла for
    [97] = "POW",               -- Возведение в степень
}

-- ============================================================
-- ЧАСТИЧНО ВОССТАНОВЛЕННАЯ ГЛАВНАЯ ФУНКЦИЯ
-- ============================================================

--[[
    Основная функция (tU) выполняет следующие действия:
    
    1. Инициализирует окружение выполнения
    2. Создает виртуальную машину с регистрами
    3. Загружает и расшифровывает байткод
    4. Выполняет инструкции в цикле
    5. Обрабатывает вызовы функций и возвраты
    6. Управляет upvalues и замыканиями
]]--

local function create_vm_environment()
    -- Создание окружения для виртуальной машины
    local env = {
        -- Регистры
        registers = {},
        
        -- Стек
        stack_top = 0,
        
        -- Константы
        constants = {},
        
        -- Прототипы функций
        prototypes = {},
        
        -- Upvalues
        upvalues = {},
        
        -- Счетчик инструкций
        pc = 1,
        
        -- Инструкции
        instructions = {}
    }
    
    return env
end

-- ============================================================
-- ОБНАРУЖЕННЫЕ ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
-- ============================================================

-- Функция для работы с байтами (частично восстановлена)
local function read_byte(data, offset)
    -- Чтение одного байта из данных
    return string.byte(data, offset)
end

-- Функция для чтения числа переменной длины
local function read_varint(data, offset)
    -- Чтение числа переменной длины (LEB128-подобный формат)
    local result = 0
    local shift = 0
    local byte
    
    repeat
        byte = string.byte(data, offset)
        offset = offset + 1
        result = result + bit32.lshift(bit32.band(byte, 0x7F), shift)
        shift = shift + 7
    until bit32.band(byte, 0x80) == 0
    
    return result, offset
end

-- ============================================================
-- СТРУКТУРА ЗАМЫКАНИЯ/ФУНКЦИИ
-- ============================================================

--[[
    Каждая функция в системе имеет следующую структуру:
    
    {
        [1] = j (string.byte),              -- Функция чтения байтов
        [2] = T.pack (string.pack),         -- Упаковка
        [3] = type,                         -- Проверка типа
        [4] = coroutine.wrap,               -- Обертка корутины
        [5] = 4503599627370496,            -- Константа (2^52)
        [6] = unpack,                       -- Распаковка массива
        [7] = nil,                          -- Резерв
        [8] = {},                           -- Таблица байткодов
        [9] = function(...),                -- Функция распаковки аргументов
        [10] = function(i,O,p),            -- Функция копирования
        [11] = string.gsub,                 -- Замена в строках
        [12] = pcall,                       -- Защищенный вызов
        [13] = nil,                         -- Резерв
        [14] = bit32.bxor,                  -- XOR
        [15] = nil,                         -- Резерв
        [16] = function(y),                 -- Декодер строк
        [17] = 1,                           -- Счетчик позиции
        [18] = nil,                         -- Резерв
        [19] = nil,                         -- Резерв
        [20] = string.sub,                  -- Подстрока
        [21] = string.unpack,               -- Распаковка
        [22] = {},                          -- Таблица инструкций
        [23] = 1,                           -- Размер
        -- ... и другие поля
    }
]]--

-- ============================================================
-- СИСТЕМА ДЕКОДИРОВАНИЯ СТРОК
-- ============================================================

--[[
    Строки закодированы специальным образом:
    
    1. Используется custom base85-подобная кодировка
    2. Символы '!' используются как escape-последовательности
    3. После раскодирования применяется gsub с заменой 'z' на '!!!'
    4. Затем применяется еще одна замена через таблицу подстановки
    
    Пример закодированной строки из кода:
    "LPH&``W;8nGiOhzaoDDAz5Z..."
    
    Алфавит кодирования (предположительно):
    "!#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{}"
]]--

-- ============================================================
-- ФУНКЦИЯ РАСШИФРОВКИ (УПРОЩЕННАЯ)
-- ============================================================

local function decode_string(encoded_str)
    -- ВНИМАНИЕ: Это упрощенная версия, не точная
    -- Реальная функция намного сложнее
    
    -- Шаг 1: Заменить 'z' на специальные символы
    local step1 = encoded_str:gsub('z', '!!!')
    
    -- Шаг 2: Декодирование base85-подобной схемы
    -- (Точная реализация скрыта в обфусцированном коде)
    
    -- Шаг 3: Применение таблицы подстановки
    -- (Таблица генерируется динамически)
    
    return "[РАСШИФРОВКА НЕВОЗМОЖНА БЕЗ ВЫПОЛНЕНИЯ КОДА]"
end

-- ============================================================
-- ИНФОРМАЦИЯ О ЗАЩИТЕ
-- ============================================================

--[[
    МЕХАНИЗМЫ ЗАЩИТЫ LURAPH:
    
    1. ВИРТУАЛИЗАЦИЯ
       - Lua байткод конвертирован в custom опкоды
       - Каждая инструкция обрабатывается через switch (100+ случаев)
       - Множественные уровни косвенности
    
    2. ШИФРОВАНИЕ СТРОК
       - Все строки зашифрованы custom алгоритмом
       - Ключи генерируются динамически
       - Используется многослойное кодирование
    
    3. ИСКАЖЕНИЕ ПОТОКА
       - Нелинейное выполнение кода
       - Фиктивные переходы и проверки
       - Запутанная логика условий
    
    4. АНТИ-ОТЛАДКА
       - Проверки целостности
       - Обнаружение модификаций
       - Защита от дампа памяти
    
    5. КОНСТАНТНЫЕ МАССИВЫ
       - Используются для деобфускации других частей
       - Связаны через битовые операции
       - Динамически модифицируются
]]--

-- ============================================================
-- ЧТО СКРИПТ ВЕРОЯТНО ДЕЛАЕТ (ПРЕДПОЛОЖЕНИЯ)
-- ============================================================

--[[
    На основе анализа структуры и паттернов:
    
    1. Это вероятно LOADER или EXECUTOR для Roblox
       - Загружает и выполняет другие скрипты
       - Имеет собственную VM для выполнения кода
       - Может обходить защиту Roblox
    
    2. Функциональность может включать:
       - Выполнение удаленных скриптов
       - Обход анти-чита
       - Инъекция кода в игру
       - Модификация игровых функций
    
    3. Использует продвинутые техники:
       - Собственная виртуальная машина
       - Динамическое создание функций
       - Работа с метатаблицами
       - Управление окружением выполнения
]]--

-- ============================================================
-- ЗАКЛЮЧЕНИЕ
-- ============================================================

--[[
    ВАЖНО ПОНИМАТЬ:
    
    1. Полная деобфускация Luraph v14.4.1 НЕВОЗМОЖНА без:
       - Динамического выполнения кода
       - Специализированных инструментов ($1000+)
       - Глубоких знаний внутреннего устройства Luraph
       - Недель/месяцев работы
    
    2. Этот файл содержит ТОЛЬКО:
       - Общую структуру
       - Обнаруженные паттерны
       - Предположения о функциональности
       - НЕ рабочий код
    
    3. Для получения рабочего кода нужно:
       - Запустить оригинальный скрипт
       - Перехватить создаваемые функции через debug hooks
       - Логировать все вызовы и операции
       - Постепенно восстанавливать логику
    
    4. ЛЕГАЛЬНОСТЬ:
       - Деобфускация может нарушать авторские права
       - Использование в Roblox нарушает ToS
       - Может быть нелегально в вашей юрисдикции
]]--

-- ============================================================
-- STUB ФУНКЦИЯ (ИМИТАЦИЯ ОРИГИНАЛА)
-- ============================================================

local function ChilliStub()
    error([[
        ОШИБКА: Это частично деобфусцированный файл.
        
        Оригинальный Chilli.lua защищен Luraph Obfuscator v14.4.1
        и не может быть полностью восстановлен без выполнения.
        
        Этот файл содержит только документацию и анализ структуры.
        
        Для использования оригинального функционала используйте Chilli.lua
    ]])
end

-- ============================================================
-- ЭКСПОРТ
-- ============================================================

return {
    -- Информация
    _NAME = "Chilli (Частично деобфусцирован)",
    _VERSION = "Partial Analysis",
    _OBFUSCATOR = "Luraph v14.4.1",
    _STATUS = "INCOMPLETE",
    
    -- Константы
    constants = U,
    
    -- Операции
    bit32 = bit32_operations,
    string = string_operations,
    table = table_operations,
    
    -- Информация об опкодах
    opcodes = OPCODES,
    
    -- Stub функция
    execute = ChilliStub,
    
    -- Предупреждение
    WARNING = "Полная деобфускация невозможна. Используйте оригинальный Chilli.lua для работы.",
}

--[[
    ============================================================
    ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ ДЛЯ АНАЛИЗА
    ============================================================
    
    Если вам нужен рабочий код, рассмотрите следующие подходы:
    
    1. ДИНАМИЧЕСКИЙ АНАЛИЗ
       ```lua
       local original = require("Chilli")
       -- Перехватите и логируйте все вызовы
       ```
    
    2. DEBUG HOOKS
       ```lua
       debug.sethook(function(event, line)
           -- Логирование выполнения
       end, "crl")
       ```
    
    3. МЕТАТАБЛИЦЫ
       ```lua
       local proxy = setmetatable({}, {
           __index = function(t, k)
               print("Access:", k)
               return original[k]
           end
       })
       ```
    
    4. ДАМП ФУНКЦИЙ
       ```lua
       for k, v in pairs(original) do
           if type(v) == "function" then
               print(k, string.dump(v))
           end
       end
       ```
    
    Удачи в анализе!
]]--
