--- a/net/minecraft/world/level/block/RedStoneWireBlock.java
+++ b/net/minecraft/world/level/block/RedStoneWireBlock.java
@@ -290,6 +290,60 @@
         return floor.isFaceSturdy(world, pos, Direction.UP) || floor.is(Blocks.HOPPER);
     }
 
+    // Paper start - Optimize redstone (Eigencraft)
+    // The bulk of the new functionality is found in RedstoneWireTurbo.java
+    com.destroystokyo.paper.util.RedstoneWireTurbo turbo = new com.destroystokyo.paper.util.RedstoneWireTurbo(this);
+
+    /*
+     * Modified version of pre-existing updateSurroundingRedstone, which is called from
+     * this.neighborChanged and a few other methods in this class.
+     * Note: Added 'source' argument so as to help determine direction of information flow
+     */
+    private void updateSurroundingRedstone(Level worldIn, BlockPos pos, BlockState state, @Nullable Orientation orientation, boolean blockAdded) {
+        if (worldIn.paperConfig().misc.redstoneImplementation == io.papermc.paper.configuration.WorldConfiguration.Misc.RedstoneImplementation.EIGENCRAFT) {
+            // since 24w33a the source pos is no longer given, but instead an Orientation parameter
+            // when this is not null, it can be used to find the source pos, which the turbo uses
+            // to find the direction of information flow
+            BlockPos source = null;
+            if (orientation != null) {
+                source = pos.relative(orientation.getFront().getOpposite());
+            }
+            turbo.updateSurroundingRedstone(worldIn, pos, state, source);
+            return;
+        }
+        updatePowerStrength(worldIn, pos, state, orientation, blockAdded);
+    }
+
+    /*
+     * This method computes a wire's target strength and updates the given block state.
+     * It uses the DefaultRedstoneWireEvaluator for this, which is identical to code
+     * that was present in this class prior to the introduction of the experimental redstone
+     * changes in 24w33a.
+     * The previous implementation of this method in this patch had optimizations that have
+     * not been relevant since 1.13, thus it has been greatly simplified.
+     */
+    public BlockState calculateCurrentChanges(Level level, BlockPos pos, BlockState state) {
+        int oldPower = state.getValue(POWER);
+        int newPower = ((DefaultRedstoneWireEvaluator) evaluator).calculateTargetStrength(level, pos);
+        if (oldPower != newPower) {
+            org.bukkit.event.block.BlockRedstoneEvent event = new org.bukkit.event.block.BlockRedstoneEvent(org.bukkit.craftbukkit.block.CraftBlock.at(level, pos), oldPower, newPower);
+            level.getCraftServer().getPluginManager().callEvent(event);
+
+            newPower = event.getNewCurrent();
+
+            if (level.getBlockState(pos) == state) {
+                state = state.setValue(POWER, newPower);
+                // [Space Walker] suppress shape updates and emit those manually to
+                // bypass the new neighbor update stack.
+                if (level.setBlock(pos, state, Block.UPDATE_KNOWN_SHAPE | Block.UPDATE_CLIENTS)) {
+                    turbo.updateNeighborShapes(level, pos, state);
+                }
+            }
+        }
+        return state;
+    }
+    // Paper end
+
     private void updatePowerStrength(Level world, BlockPos pos, BlockState state, @Nullable Orientation orientation, boolean blockAdded) {
         if (useExperimentalEvaluator(world)) {
             new ExperimentalRedstoneWireEvaluator(this).updatePowerStrength(world, pos, state, orientation, blockAdded);
@@ -318,7 +372,13 @@
     @Override
     protected void onPlace(BlockState state, Level world, BlockPos pos, BlockState oldState, boolean notify) {
         if (!oldState.is(state.getBlock()) && !world.isClientSide) {
-            this.updatePowerStrength(world, pos, state, null, true);
+            // Paper start - optimize redstone - replace call to updatePowerStrength
+            if (world.paperConfig().misc.redstoneImplementation == io.papermc.paper.configuration.WorldConfiguration.Misc.RedstoneImplementation.ALTERNATE_CURRENT) {
+                world.getWireHandler().onWireAdded(pos, state); // Alternate Current
+            } else {
+                this.updateSurroundingRedstone(world, pos, state, null, true); // Vanilla/Eigencraft
+            }
+            // Paper end
 
             for (Direction direction : Direction.Plane.VERTICAL) {
                 world.updateNeighborsAt(pos.relative(direction), this);
@@ -337,7 +397,12 @@
                     world.updateNeighborsAt(pos.relative(direction), this);
                 }
 
-                this.updatePowerStrength(world, pos, state, null, false);
+                // Paper start - optimize redstone - replace call to updatePowerStrength
+                if (world.paperConfig().misc.redstoneImplementation == io.papermc.paper.configuration.WorldConfiguration.Misc.RedstoneImplementation.ALTERNATE_CURRENT) {
+                    world.getWireHandler().onWireRemoved(pos, state); // Alternate Current
+                } else {
+                    this.updateSurroundingRedstone(world, pos, state, null, false); // Vanilla/Eigencraft
+                }
                 this.updateNeighborsOfNeighboringWires(world, pos);
             }
         }
@@ -361,9 +426,15 @@
     @Override
     protected void neighborChanged(BlockState state, Level world, BlockPos pos, Block sourceBlock, @Nullable Orientation wireOrientation, boolean notify) {
         if (!world.isClientSide) {
+            // Paper start - optimize redstone (Alternate Current)
+            // Alternate Current handles breaking of redstone wires in the WireHandler.
+            if (world.paperConfig().misc.redstoneImplementation == io.papermc.paper.configuration.WorldConfiguration.Misc.RedstoneImplementation.ALTERNATE_CURRENT) {
+                world.getWireHandler().onWireUpdated(pos, state, wireOrientation);
+            } else
+            // Paper end - optimize redstone (Alternate Current)
             if (sourceBlock != this || !useExperimentalEvaluator(world)) {
                 if (state.canSurvive(world, pos)) {
-                    this.updatePowerStrength(world, pos, state, wireOrientation, false);
+                    this.updateSurroundingRedstone(world, pos, state, wireOrientation, false); // Paper - Optimize redstone (Eigencraft)
                 } else {
                     dropResources(state, world, pos);
                     world.removeBlock(pos, false);
