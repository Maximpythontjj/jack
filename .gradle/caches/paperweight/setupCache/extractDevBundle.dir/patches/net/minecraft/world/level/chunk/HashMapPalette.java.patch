--- a/net/minecraft/world/level/chunk/HashMapPalette.java
+++ b/net/minecraft/world/level/chunk/HashMapPalette.java
@@ -8,19 +8,26 @@
 import net.minecraft.network.VarInt;
 import net.minecraft.util.CrudeIncrementalIntIdentityHashBiMap;
 
-public class HashMapPalette<T> implements Palette<T> {
+public class HashMapPalette<T> implements Palette<T>, ca.spottedleaf.moonrise.patches.fast_palette.FastPalette<T> { // Paper - optimise palette reads
     private final IdMap<T> registry;
     private final CrudeIncrementalIntIdentityHashBiMap<T> values;
     private final PaletteResize<T> resizeHandler;
     private final int bits;
 
+    // Paper start - optimise palette reads
+    @Override
+    public final T[] moonrise$getRawPalette(final ca.spottedleaf.moonrise.patches.fast_palette.FastPaletteData<T> container) {
+        return ((ca.spottedleaf.moonrise.patches.fast_palette.FastPalette<T>)this.values).moonrise$getRawPalette(container);
+    }
+    // Paper end - optimise palette reads
+
     public HashMapPalette(IdMap<T> idList, int bits, PaletteResize<T> listener, List<T> entries) {
         this(idList, bits, listener);
         entries.forEach(this.values::add);
     }
 
     public HashMapPalette(IdMap<T> idList, int indexBits, PaletteResize<T> listener) {
-        this(idList, indexBits, listener, CrudeIncrementalIntIdentityHashBiMap.create(1 << indexBits));
+        this(idList, indexBits, listener, CrudeIncrementalIntIdentityHashBiMap.create((1 << indexBits) + 1)); // Paper - Perf: Avoid unnecessary resize operation in CrudeIncrementalIntIdentityHashBiMap
     }
 
     private HashMapPalette(IdMap<T> idList, int indexBits, PaletteResize<T> listener, CrudeIncrementalIntIdentityHashBiMap<T> map) {
@@ -38,10 +45,16 @@
     public int idFor(T object) {
         int i = this.values.getId(object);
         if (i == -1) {
-            i = this.values.add(object);
-            if (i >= 1 << this.bits) {
+            // Paper start - Perf: Avoid unnecessary resize operation in CrudeIncrementalIntIdentityHashBiMap and optimize
+            // We use size() instead of the result from add(K)
+            // This avoids adding another object unnecessarily
+            // Without this change, + 2 would be required in the constructor
+            if (this.values.size() >= 1 << this.bits) {
                 i = this.resizeHandler.onResize(this.bits + 1, object);
+            } else {
+                i = this.values.add(object);
             }
+            // Paper end - Perf: Avoid unnecessary resize operation in CrudeIncrementalIntIdentityHashBiMap and optimize
         }
 
         return i;
