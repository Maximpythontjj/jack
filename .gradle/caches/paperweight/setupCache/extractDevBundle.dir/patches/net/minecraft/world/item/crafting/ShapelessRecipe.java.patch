--- a/net/minecraft/world/item/crafting/ShapelessRecipe.java
+++ b/net/minecraft/world/item/crafting/ShapelessRecipe.java
@@ -9,14 +9,22 @@
 import net.minecraft.network.RegistryFriendlyByteBuf;
 import net.minecraft.network.codec.ByteBufCodecs;
 import net.minecraft.network.codec.StreamCodec;
+import net.minecraft.world.entity.player.StackedContents;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.item.crafting.display.RecipeDisplay;
 import net.minecraft.world.item.crafting.display.ShapelessCraftingRecipeDisplay;
 import net.minecraft.world.item.crafting.display.SlotDisplay;
 import net.minecraft.world.level.Level;
+// CraftBukkit start
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.inventory.CraftRecipe;
+import org.bukkit.craftbukkit.inventory.CraftShapelessRecipe;
+// CraftBukkit end
 
 public class ShapelessRecipe implements CraftingRecipe {
+
     final String group;
     final CraftingBookCategory category;
     final ItemStack result;
@@ -31,6 +39,22 @@
         this.ingredients = ingredients;
     }
 
+    // CraftBukkit start
+    @SuppressWarnings("unchecked")
+    @Override
+    public org.bukkit.inventory.ShapelessRecipe toBukkitRecipe(NamespacedKey id) {
+        CraftItemStack result = CraftItemStack.asCraftMirror(this.result);
+        CraftShapelessRecipe recipe = new CraftShapelessRecipe(id, result, this);
+        recipe.setGroup(this.group);
+        recipe.setCategory(CraftRecipe.getCategory(this.category()));
+
+        for (Ingredient list : this.ingredients) {
+            recipe.addIngredient(CraftRecipe.toBukkit(list));
+        }
+        return recipe;
+    }
+    // CraftBukkit end
+
     @Override
     public RecipeSerializer<ShapelessRecipe> getSerializer() {
         return RecipeSerializer.SHAPELESS_RECIPE;
@@ -55,63 +79,63 @@
         return this.placementInfo;
     }
 
-    @Override
     public boolean matches(CraftingInput input, Level world) {
+        // Paper start - Improve exact choice recipe ingredients & unwrap ternary
         if (input.ingredientCount() != this.ingredients.size()) {
             return false;
-        } else {
-            return input.size() == 1 && this.ingredients.size() == 1
-                ? this.ingredients.getFirst().test(input.getItem(0))
-                : input.stackedContents().canCraft(this, null);
         }
+        if (input.size() == 1 && this.ingredients.size() == 1) {
+            return this.ingredients.getFirst().test(input.getItem(0));
+        }
+        input.stackedContents().initializeExtras(this, input);
+        boolean canCraft = input.stackedContents().canCraft(this, null);
+        input.stackedContents().resetExtras();
+        return canCraft;
+        // Paper end - Improve exact choice recipe ingredients & unwrap ternary
     }
 
-    @Override
     public ItemStack assemble(CraftingInput input, HolderLookup.Provider registries) {
         return this.result.copy();
     }
 
     @Override
     public List<RecipeDisplay> display() {
-        return List.of(
-            new ShapelessCraftingRecipeDisplay(
-                this.ingredients.stream().map(Ingredient::display).toList(),
-                new SlotDisplay.ItemStackSlotDisplay(this.result),
-                new SlotDisplay.ItemSlotDisplay(Items.CRAFTING_TABLE)
-            )
-        );
+        return List.of(new ShapelessCraftingRecipeDisplay(this.ingredients.stream().map(Ingredient::display).toList(), new SlotDisplay.ItemStackSlotDisplay(this.result), new SlotDisplay.ItemSlotDisplay(Items.CRAFTING_TABLE)));
     }
 
     public static class Serializer implements RecipeSerializer<ShapelessRecipe> {
-        private static final MapCodec<ShapelessRecipe> CODEC = RecordCodecBuilder.mapCodec(
-            instance -> instance.group(
-                        Codec.STRING.optionalFieldOf("group", "").forGetter(recipe -> recipe.group),
-                        CraftingBookCategory.CODEC.fieldOf("category").orElse(CraftingBookCategory.MISC).forGetter(recipe -> recipe.category),
-                        ItemStack.STRICT_CODEC.fieldOf("result").forGetter(recipe -> recipe.result),
-                        Ingredient.CODEC.listOf(1, 9).fieldOf("ingredients").forGetter(recipe -> recipe.ingredients)
-                    )
-                    .apply(instance, ShapelessRecipe::new)
-        );
-        public static final StreamCodec<RegistryFriendlyByteBuf, ShapelessRecipe> STREAM_CODEC = StreamCodec.composite(
-            ByteBufCodecs.STRING_UTF8,
-            recipe -> recipe.group,
-            CraftingBookCategory.STREAM_CODEC,
-            recipe -> recipe.category,
-            ItemStack.STREAM_CODEC,
-            recipe -> recipe.result,
-            Ingredient.CONTENTS_STREAM_CODEC.apply(ByteBufCodecs.list()),
-            recipe -> recipe.ingredients,
-            ShapelessRecipe::new
-        );
+
+        private static final MapCodec<ShapelessRecipe> CODEC = RecordCodecBuilder.mapCodec((instance) -> {
+            return instance.group(Codec.STRING.optionalFieldOf("group", "").forGetter((shapelessrecipes) -> {
+                return shapelessrecipes.group;
+            }), CraftingBookCategory.CODEC.fieldOf("category").orElse(CraftingBookCategory.MISC).forGetter((shapelessrecipes) -> {
+                return shapelessrecipes.category;
+            }), ItemStack.STRICT_CODEC.fieldOf("result").forGetter((shapelessrecipes) -> {
+                return shapelessrecipes.result;
+            }), Ingredient.CODEC.listOf(1, 9).fieldOf("ingredients").forGetter((shapelessrecipes) -> {
+                return shapelessrecipes.ingredients;
+            })).apply(instance, ShapelessRecipe::new);
+        });
+        public static final StreamCodec<RegistryFriendlyByteBuf, ShapelessRecipe> STREAM_CODEC = StreamCodec.composite(ByteBufCodecs.STRING_UTF8, (shapelessrecipes) -> {
+            return shapelessrecipes.group;
+        }, CraftingBookCategory.STREAM_CODEC, (shapelessrecipes) -> {
+            return shapelessrecipes.category;
+        }, ItemStack.STREAM_CODEC, (shapelessrecipes) -> {
+            return shapelessrecipes.result;
+        }, Ingredient.CONTENTS_STREAM_CODEC.apply(ByteBufCodecs.list()), (shapelessrecipes) -> {
+            return shapelessrecipes.ingredients;
+        }, ShapelessRecipe::new);
+
+        public Serializer() {}
 
         @Override
         public MapCodec<ShapelessRecipe> codec() {
-            return CODEC;
+            return ShapelessRecipe.Serializer.CODEC;
         }
 
         @Override
         public StreamCodec<RegistryFriendlyByteBuf, ShapelessRecipe> streamCodec() {
-            return STREAM_CODEC;
+            return ShapelessRecipe.Serializer.STREAM_CODEC;
         }
     }
 }
