--- a/net/minecraft/world/item/component/Consumable.java
+++ b/net/minecraft/world/item/component/Consumable.java
@@ -29,62 +29,65 @@
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.gameevent.GameEvent;
 
-public record Consumable(
-    float consumeSeconds, ItemUseAnimation animation, Holder<SoundEvent> sound, boolean hasConsumeParticles, List<ConsumeEffect> onConsumeEffects
-) {
+// CraftBukkit start
+import net.minecraft.world.item.Items;
+import org.bukkit.event.entity.EntityPotionEffectEvent;
+// CraftBukkit end
+
+public record Consumable(float consumeSeconds, ItemUseAnimation animation, Holder<SoundEvent> sound, boolean hasConsumeParticles, List<ConsumeEffect> onConsumeEffects) {
+
     public static final float DEFAULT_CONSUME_SECONDS = 1.6F;
     private static final int CONSUME_EFFECTS_INTERVAL = 4;
     private static final float CONSUME_EFFECTS_START_FRACTION = 0.21875F;
-    public static final Codec<Consumable> CODEC = RecordCodecBuilder.create(
-        instance -> instance.group(
-                    ExtraCodecs.NON_NEGATIVE_FLOAT.optionalFieldOf("consume_seconds", 1.6F).forGetter(Consumable::consumeSeconds),
-                    ItemUseAnimation.CODEC.optionalFieldOf("animation", ItemUseAnimation.EAT).forGetter(Consumable::animation),
-                    SoundEvent.CODEC.optionalFieldOf("sound", SoundEvents.GENERIC_EAT).forGetter(Consumable::sound),
-                    Codec.BOOL.optionalFieldOf("has_consume_particles", Boolean.valueOf(true)).forGetter(Consumable::hasConsumeParticles),
-                    ConsumeEffect.CODEC.listOf().optionalFieldOf("on_consume_effects", List.of()).forGetter(Consumable::onConsumeEffects)
-                )
-                .apply(instance, Consumable::new)
-    );
-    public static final StreamCodec<RegistryFriendlyByteBuf, Consumable> STREAM_CODEC = StreamCodec.composite(
-        ByteBufCodecs.FLOAT,
-        Consumable::consumeSeconds,
-        ItemUseAnimation.STREAM_CODEC,
-        Consumable::animation,
-        SoundEvent.STREAM_CODEC,
-        Consumable::sound,
-        ByteBufCodecs.BOOL,
-        Consumable::hasConsumeParticles,
-        ConsumeEffect.STREAM_CODEC.apply(ByteBufCodecs.list()),
-        Consumable::onConsumeEffects,
-        Consumable::new
-    );
+    public static final Codec<Consumable> CODEC = RecordCodecBuilder.create((instance) -> {
+        return instance.group(ExtraCodecs.NON_NEGATIVE_FLOAT.optionalFieldOf("consume_seconds", 1.6F).forGetter(Consumable::consumeSeconds), ItemUseAnimation.CODEC.optionalFieldOf("animation", ItemUseAnimation.EAT).forGetter(Consumable::animation), SoundEvent.CODEC.optionalFieldOf("sound", SoundEvents.GENERIC_EAT).forGetter(Consumable::sound), Codec.BOOL.optionalFieldOf("has_consume_particles", true).forGetter(Consumable::hasConsumeParticles), ConsumeEffect.CODEC.listOf().optionalFieldOf("on_consume_effects", List.of()).forGetter(Consumable::onConsumeEffects)).apply(instance, Consumable::new);
+    });
+    public static final StreamCodec<RegistryFriendlyByteBuf, Consumable> STREAM_CODEC = StreamCodec.composite(ByteBufCodecs.FLOAT, Consumable::consumeSeconds, ItemUseAnimation.STREAM_CODEC, Consumable::animation, SoundEvent.STREAM_CODEC, Consumable::sound, ByteBufCodecs.BOOL, Consumable::hasConsumeParticles, ConsumeEffect.STREAM_CODEC.apply(ByteBufCodecs.list()), Consumable::onConsumeEffects, Consumable::new);
 
     public InteractionResult startConsuming(LivingEntity user, ItemStack stack, InteractionHand hand) {
         if (!this.canConsume(user, stack)) {
             return InteractionResult.FAIL;
         } else {
-            boolean bl = this.consumeTicks() > 0;
-            if (bl) {
+            boolean flag = this.consumeTicks() > 0;
+
+            if (flag) {
                 user.startUsingItem(hand);
                 return InteractionResult.CONSUME;
             } else {
-                ItemStack itemStack = this.onConsume(user.level(), user, stack);
-                return InteractionResult.CONSUME.heldItemTransformedTo(itemStack);
+                ItemStack itemstack1 = this.onConsume(user.level(), user, stack);
+
+                return InteractionResult.CONSUME.heldItemTransformedTo(itemstack1);
             }
         }
     }
 
     public ItemStack onConsume(Level world, LivingEntity user, ItemStack stack) {
-        RandomSource randomSource = user.getRandom();
-        this.emitParticlesAndSounds(randomSource, user, stack, 16);
-        if (user instanceof ServerPlayer serverPlayer) {
-            serverPlayer.awardStat(Stats.ITEM_USED.get(stack.getItem()));
-            CriteriaTriggers.CONSUME_ITEM.trigger(serverPlayer, stack);
+        RandomSource randomsource = user.getRandom();
+
+        this.emitParticlesAndSounds(randomsource, user, stack, 16);
+        if (user instanceof ServerPlayer entityplayer) {
+            entityplayer.awardStat(Stats.ITEM_USED.get(stack.getItem()));
+            CriteriaTriggers.CONSUME_ITEM.trigger(entityplayer, stack);
         }
 
-        stack.getAllOfType(ConsumableListener.class).forEach(consumable -> consumable.onConsume(world, user, stack, this));
+        stack.getAllOfType(ConsumableListener.class).forEach((consumablelistener) -> {
+            consumablelistener.onConsume(world, user, stack, this);
+        });
         if (!world.isClientSide) {
-            this.onConsumeEffects.forEach(effect -> effect.apply(world, stack, user));
+            // CraftBukkit start
+            EntityPotionEffectEvent.Cause cause;
+            if (stack.is(Items.MILK_BUCKET)) {
+                cause = EntityPotionEffectEvent.Cause.MILK;
+            } else if (stack.is(Items.POTION)) {
+                cause = EntityPotionEffectEvent.Cause.POTION_DRINK;
+            } else {
+                cause = EntityPotionEffectEvent.Cause.FOOD;
+            }
+
+            this.onConsumeEffects.forEach((consumeeffect) -> {
+                consumeeffect.apply(world, stack, user, cause);
+                // CraftBukkit end
+            });
         }
 
         user.gameEvent(this.animation == ItemUseAnimation.DRINK ? GameEvent.DRINK : GameEvent.EAT);
@@ -92,51 +95,86 @@
         return stack;
     }
 
+    // CraftBukkit start
+    public void cancelUsingItem(net.minecraft.server.level.ServerPlayer entityplayer, ItemStack itemstack) {
+        final java.util.List<net.minecraft.network.protocol.Packet<? super net.minecraft.network.protocol.game.ClientGamePacketListener>> packets = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Paper - properly resend entities - collect packets for bundle
+        itemstack.getAllOfType(ConsumableListener.class).forEach((consumablelistener) -> {
+            consumablelistener.cancelUsingItem(entityplayer, itemstack, packets); // Paper - properly resend entities - collect packets for bundle
+        });
+        entityplayer.server.getPlayerList().sendActiveEffects(entityplayer, packets::add); // Paper - properly resend entities - collect packets for bundle
+        entityplayer.connection.send(new net.minecraft.network.protocol.game.ClientboundBundlePacket(packets));
+    }
+    // CraftBukkit end
+
     public boolean canConsume(LivingEntity user, ItemStack stack) {
-        FoodProperties foodProperties = stack.get(DataComponents.FOOD);
-        return foodProperties == null || !(user instanceof Player player) || player.canEat(foodProperties.canAlwaysEat());
+        FoodProperties foodinfo = (FoodProperties) stack.get(DataComponents.FOOD);
+
+        if (foodinfo != null && user instanceof Player entityhuman) {
+            return entityhuman.canEat(foodinfo.canAlwaysEat());
+        } else {
+            return true;
+        }
     }
 
     public int consumeTicks() {
-        return (int)(this.consumeSeconds * 20.0F);
+        return (int) (this.consumeSeconds * 20.0F);
     }
 
     public void emitParticlesAndSounds(RandomSource random, LivingEntity user, ItemStack stack, int particleCount) {
         float f = random.nextBoolean() ? 0.5F : 1.0F;
-        float g = random.triangle(1.0F, 0.2F);
-        float h = 0.5F;
-        float i = Mth.randomBetween(random, 0.9F, 1.0F);
-        float j = this.animation == ItemUseAnimation.DRINK ? 0.5F : f;
-        float k = this.animation == ItemUseAnimation.DRINK ? i : g;
+        float f1 = random.triangle(1.0F, 0.2F);
+        float f2 = 0.5F;
+        float f3 = Mth.randomBetween(random, 0.9F, 1.0F);
+        float f4 = this.animation == ItemUseAnimation.DRINK ? 0.5F : f;
+        float f5 = this.animation == ItemUseAnimation.DRINK ? f3 : f1;
+
         if (this.hasConsumeParticles) {
             user.spawnItemParticles(stack, particleCount);
         }
 
-        SoundEvent soundEvent = user instanceof Consumable.OverrideConsumeSound overrideConsumeSound
-            ? overrideConsumeSound.getConsumeSound(stack)
-            : this.sound.value();
-        user.playSound(soundEvent, j, k);
+        SoundEvent soundeffect;
+
+        if (user instanceof Consumable.OverrideConsumeSound consumable_b) {
+            soundeffect = consumable_b.getConsumeSound(stack);
+        } else {
+            soundeffect = (SoundEvent) this.sound.value();
+        }
+
+        SoundEvent soundeffect1 = soundeffect;
+
+        user.playSound(soundeffect1, f4, f5);
     }
 
     public boolean shouldEmitParticlesAndSounds(int remainingUseTicks) {
-        int i = this.consumeTicks() - remainingUseTicks;
-        int j = (int)((float)this.consumeTicks() * 0.21875F);
-        boolean bl = i > j;
-        return bl && remainingUseTicks % 4 == 0;
+        int j = this.consumeTicks() - remainingUseTicks;
+        int k = (int) ((float) this.consumeTicks() * 0.21875F);
+        boolean flag = j > k;
+
+        return flag && remainingUseTicks % 4 == 0;
     }
 
     public static Consumable.Builder builder() {
         return new Consumable.Builder();
     }
 
+    public interface OverrideConsumeSound {
+
+        SoundEvent getConsumeSound(ItemStack stack);
+    }
+
     public static class Builder {
+
         private float consumeSeconds = 1.6F;
-        private ItemUseAnimation animation = ItemUseAnimation.EAT;
-        private Holder<SoundEvent> sound = SoundEvents.GENERIC_EAT;
-        private boolean hasConsumeParticles = true;
-        private final List<ConsumeEffect> onConsumeEffects = new ArrayList<>();
+        private ItemUseAnimation animation;
+        private Holder<SoundEvent> sound;
+        private boolean hasConsumeParticles;
+        private final List<ConsumeEffect> onConsumeEffects;
 
         Builder() {
+            this.animation = ItemUseAnimation.EAT;
+            this.sound = SoundEvents.GENERIC_EAT;
+            this.hasConsumeParticles = true;
+            this.onConsumeEffects = new ArrayList();
         }
 
         public Consumable.Builder consumeSeconds(float consumeSeconds) {
@@ -172,8 +210,4 @@
             return new Consumable(this.consumeSeconds, this.animation, this.sound, this.hasConsumeParticles, this.onConsumeEffects);
         }
     }
-
-    public interface OverrideConsumeSound {
-        SoundEvent getConsumeSound(ItemStack stack);
-    }
 }
