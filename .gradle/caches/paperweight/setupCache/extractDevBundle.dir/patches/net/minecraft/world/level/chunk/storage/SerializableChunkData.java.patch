--- a/net/minecraft/world/level/chunk/storage/SerializableChunkData.java
+++ b/net/minecraft/world/level/chunk/storage/SerializableChunkData.java
@@ -4,6 +4,7 @@
 import com.google.common.collect.Maps;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortArrayList;
@@ -12,10 +13,11 @@
 import java.util.Arrays;
 import java.util.EnumMap;
 import java.util.EnumSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Map.Entry;
+import java.util.Objects;
 import javax.annotation.Nullable;
 import net.minecraft.Optionull;
 import net.minecraft.core.BlockPos;
@@ -32,8 +34,11 @@
 import net.minecraft.nbt.NbtOps;
 import net.minecraft.nbt.NbtUtils;
 import net.minecraft.nbt.ShortTag;
+import net.minecraft.nbt.Tag;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerChunkCache;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ThreadedLevelLightEngine;
 import net.minecraft.world.entity.EntitySpawnReason;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.ai.village.poi.PoiManager;
@@ -48,7 +53,6 @@
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.CarvingMask;
 import net.minecraft.world.level.chunk.ChunkAccess;
-import net.minecraft.world.level.chunk.ChunkSource;
 import net.minecraft.world.level.chunk.DataLayer;
 import net.minecraft.world.level.chunk.ImposterProtoChunk;
 import net.minecraft.world.level.chunk.LevelChunk;
@@ -72,29 +76,10 @@
 import net.minecraft.world.ticks.SavedTick;
 import org.slf4j.Logger;
 
-public record SerializableChunkData(
-    Registry<Biome> biomeRegistry,
-    ChunkPos chunkPos,
-    int minSectionY,
-    long lastUpdateTime,
-    long inhabitedTime,
-    ChunkStatus chunkStatus,
-    @Nullable BlendingData.Packed blendingData,
-    @Nullable BelowZeroRetrogen belowZeroRetrogen,
-    UpgradeData upgradeData,
-    @Nullable long[] carvingMask,
-    Map<Heightmap.Types, long[]> heightmaps,
-    ChunkAccess.PackedTicks packedTicks,
-    ShortList[] postProcessingSections,
-    boolean lightCorrect,
-    List<SerializableChunkData.SectionData> sectionData,
-    List<CompoundTag> entities,
-    List<CompoundTag> blockEntities,
-    CompoundTag structureData
-) {
-    public static final Codec<PalettedContainer<BlockState>> BLOCK_STATE_CODEC = PalettedContainer.codecRW(
-        Block.BLOCK_STATE_REGISTRY, BlockState.CODEC, PalettedContainer.Strategy.SECTION_STATES, Blocks.AIR.defaultBlockState()
-    );
+// CraftBukkit - persistentDataContainer
+public record SerializableChunkData(Registry<Biome> biomeRegistry, ChunkPos chunkPos, int minSectionY, long lastUpdateTime, long inhabitedTime, ChunkStatus chunkStatus, @Nullable BlendingData.Packed blendingData, @Nullable BelowZeroRetrogen belowZeroRetrogen, UpgradeData upgradeData, @Nullable long[] carvingMask, Map<Heightmap.Types, long[]> heightmaps, ChunkAccess.PackedTicks packedTicks, ShortList[] postProcessingSections, boolean lightCorrect, List<SerializableChunkData.SectionData> sectionData, List<CompoundTag> entities, List<CompoundTag> blockEntities, CompoundTag structureData, @Nullable Tag persistentDataContainer) {
+
+    public static final Codec<PalettedContainer<BlockState>> BLOCK_STATE_CODEC = PalettedContainer.codecRW(Block.BLOCK_STATE_REGISTRY, BlockState.CODEC, PalettedContainer.Strategy.SECTION_STATES, Blocks.AIR.defaultBlockState(), null); // Paper start - Anti-Xray
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final String TAG_UPGRADE_DATA = "UpgradeData";
     private static final String BLOCK_TICKS_TAG = "block_ticks";
@@ -106,441 +91,640 @@
     public static final String SECTIONS_TAG = "sections";
     public static final String BLOCK_LIGHT_TAG = "BlockLight";
     public static final String SKY_LIGHT_TAG = "SkyLight";
+    // Paper start - guard against serializing mismatching coordinates
+    // TODO Note: This needs to be re-checked each update
+    public static ChunkPos getChunkCoordinate(final CompoundTag chunkData) {
+        final int dataVersion = ChunkStorage.getVersion(chunkData);
+        if (dataVersion < 2842) { // Level tag is removed after this version
+            final CompoundTag levelData = chunkData.getCompound("Level");
+            return new ChunkPos(levelData.getInt("xPos"), levelData.getInt("zPos"));
+        } else {
+            return new ChunkPos(chunkData.getInt("xPos"), chunkData.getInt("zPos"));
+        }
+    }
+    // Paper end - guard against serializing mismatching coordinates
+    // Paper start - Attempt to recalculate regionfile header if it is corrupt
+    // TODO: Check on update
+    public static long getLastWorldSaveTime(final CompoundTag chunkData) {
+        final int dataVersion = ChunkStorage.getVersion(chunkData);
+        if (dataVersion < 2842) { // Level tag is removed after this version
+            final CompoundTag levelData = chunkData.getCompound("Level");
+            return levelData.getLong("LastUpdate");
+        } else {
+            return chunkData.getLong("LastUpdate");
+        }
+    }
+    // Paper end - Attempt to recalculate regionfile header if it is corrupt
+
+    // Paper start - Do not let the server load chunks from newer versions
+    private static final int CURRENT_DATA_VERSION = net.minecraft.SharedConstants.getCurrentVersion().getDataVersion().getVersion();
+    private static final boolean JUST_CORRUPT_IT = Boolean.getBoolean("Paper.ignoreWorldDataVersion");
+    // Paper end - Do not let the server load chunks from newer versions
 
     @Nullable
     public static SerializableChunkData parse(LevelHeightAccessor world, RegistryAccess registryManager, CompoundTag nbt) {
+        net.minecraft.server.level.ServerLevel serverLevel = (net.minecraft.server.level.ServerLevel) world; // Paper - Anti-Xray This is is seemingly only called from ChunkMap, where, we have a server level. We'll fight this later if needed.
         if (!nbt.contains("Status", 8)) {
             return null;
         } else {
-            ChunkPos chunkPos = new ChunkPos(nbt.getInt("xPos"), nbt.getInt("zPos"));
-            long l = nbt.getLong("LastUpdate");
-            long m = nbt.getLong("InhabitedTime");
-            ChunkStatus chunkStatus = ChunkStatus.byName(nbt.getString("Status"));
-            UpgradeData upgradeData = nbt.contains("UpgradeData", 10) ? new UpgradeData(nbt.getCompound("UpgradeData"), world) : UpgradeData.EMPTY;
-            boolean bl = nbt.getBoolean("isLightOn");
-            BlendingData.Packed packed;
+            // Paper start - Do not let the server load chunks from newer versions
+            if (nbt.contains("DataVersion", net.minecraft.nbt.Tag.TAG_ANY_NUMERIC)) {
+                final int dataVersion = nbt.getInt("DataVersion");
+                if (!JUST_CORRUPT_IT && dataVersion > CURRENT_DATA_VERSION) {
+                    new RuntimeException("Server attempted to load chunk saved with newer version of minecraft! " + dataVersion + " > " + CURRENT_DATA_VERSION).printStackTrace();
+                    System.exit(1);
+                }
+            }
+            // Paper end - Do not let the server load chunks from newer versions
+            ChunkPos chunkcoordintpair = new ChunkPos(nbt.getInt("xPos"), nbt.getInt("zPos")); // Paper - guard against serializing mismatching coordinates; diff on change, see ChunkSerializer#getChunkCoordinate
+            long i = nbt.getLong("LastUpdate");
+            long j = nbt.getLong("InhabitedTime");
+            ChunkStatus chunkstatus = ChunkStatus.byName(nbt.getString("Status"));
+            UpgradeData chunkconverter = nbt.contains("UpgradeData", 10) ? new UpgradeData(nbt.getCompound("UpgradeData"), world) : UpgradeData.EMPTY;
+            boolean flag = chunkstatus.isOrAfter(ChunkStatus.LIGHT) && (nbt.get("isLightOn") != null && nbt.getInt(ca.spottedleaf.moonrise.patches.starlight.util.SaveUtil.STARLIGHT_VERSION_TAG) == ca.spottedleaf.moonrise.patches.starlight.util.SaveUtil.STARLIGHT_LIGHT_VERSION); // Paper - starlight
+            DataResult dataresult;
+            Logger logger;
+            BlendingData.Packed blendingdata_d;
+
             if (nbt.contains("blending_data", 10)) {
-                packed = BlendingData.Packed.CODEC.parse(NbtOps.INSTANCE, nbt.getCompound("blending_data")).resultOrPartial(LOGGER::error).orElse(null);
+                dataresult = BlendingData.Packed.CODEC.parse(NbtOps.INSTANCE, nbt.getCompound("blending_data"));
+                logger = SerializableChunkData.LOGGER;
+                Objects.requireNonNull(logger);
+                blendingdata_d = (BlendingData.Packed) ((DataResult<BlendingData.Packed>) dataresult).resultOrPartial(logger::error).orElse(null); // CraftBukkit - decompile error
             } else {
-                packed = null;
+                blendingdata_d = null;
             }
 
-            BelowZeroRetrogen belowZeroRetrogen;
+            BelowZeroRetrogen belowzeroretrogen;
+
             if (nbt.contains("below_zero_retrogen", 10)) {
-                belowZeroRetrogen = BelowZeroRetrogen.CODEC
-                    .parse(NbtOps.INSTANCE, nbt.getCompound("below_zero_retrogen"))
-                    .resultOrPartial(LOGGER::error)
-                    .orElse(null);
+                dataresult = BelowZeroRetrogen.CODEC.parse(NbtOps.INSTANCE, nbt.getCompound("below_zero_retrogen"));
+                logger = SerializableChunkData.LOGGER;
+                Objects.requireNonNull(logger);
+                belowzeroretrogen = (BelowZeroRetrogen) ((DataResult<BelowZeroRetrogen>) dataresult).resultOrPartial(logger::error).orElse(null); // CraftBukkit - decompile error
             } else {
-                belowZeroRetrogen = null;
+                belowzeroretrogen = null;
             }
 
-            long[] ls;
+            long[] along;
+
             if (nbt.contains("carving_mask", 12)) {
-                ls = nbt.getLongArray("carving_mask");
+                along = nbt.getLongArray("carving_mask");
             } else {
-                ls = null;
+                along = null;
             }
 
-            CompoundTag compoundTag = nbt.getCompound("Heightmaps");
-            Map<Heightmap.Types, long[]> map = new EnumMap<>(Heightmap.Types.class);
+            CompoundTag nbttagcompound1 = nbt.getCompound("Heightmaps");
+            Map<Heightmap.Types, long[]> map = new EnumMap(Heightmap.Types.class);
+            Iterator iterator = chunkstatus.heightmapsAfter().iterator();
 
-            for (Heightmap.Types types : chunkStatus.heightmapsAfter()) {
-                String string = types.getSerializationKey();
-                if (compoundTag.contains(string, 12)) {
-                    map.put(types, compoundTag.getLongArray(string));
+            while (iterator.hasNext()) {
+                Heightmap.Types heightmap_type = (Heightmap.Types) iterator.next();
+                String s = heightmap_type.getSerializationKey();
+
+                if (nbttagcompound1.contains(s, 12)) {
+                    map.put(heightmap_type, nbttagcompound1.getLongArray(s));
                 }
             }
 
-            List<SavedTick<Block>> list = SavedTick.loadTickList(
-                nbt.getList("block_ticks", 10), id -> BuiltInRegistries.BLOCK.getOptional(ResourceLocation.tryParse(id)), chunkPos
-            );
-            List<SavedTick<Fluid>> list2 = SavedTick.loadTickList(
-                nbt.getList("fluid_ticks", 10), id -> BuiltInRegistries.FLUID.getOptional(ResourceLocation.tryParse(id)), chunkPos
-            );
-            ChunkAccess.PackedTicks packedTicks = new ChunkAccess.PackedTicks(list, list2);
-            ListTag listTag = nbt.getList("PostProcessing", 9);
-            ShortList[] shortLists = new ShortList[listTag.size()];
+            List<SavedTick<Block>> list = SavedTick.loadTickList(nbt.getList("block_ticks", 10), (s1) -> {
+                return BuiltInRegistries.BLOCK.getOptional(ResourceLocation.tryParse(s1));
+            }, chunkcoordintpair);
+            List<SavedTick<Fluid>> list1 = SavedTick.loadTickList(nbt.getList("fluid_ticks", 10), (s1) -> {
+                return BuiltInRegistries.FLUID.getOptional(ResourceLocation.tryParse(s1));
+            }, chunkcoordintpair);
+            ChunkAccess.PackedTicks ichunkaccess_a = new ChunkAccess.PackedTicks(list, list1);
+            ListTag nbttaglist = nbt.getList("PostProcessing", 9);
+            ShortList[] ashortlist = new ShortList[nbttaglist.size()];
 
-            for (int i = 0; i < listTag.size(); i++) {
-                ListTag listTag2 = listTag.getList(i);
-                ShortList shortList = new ShortArrayList(listTag2.size());
+            for (int k = 0; k < nbttaglist.size(); ++k) {
+                ListTag nbttaglist1 = nbttaglist.getList(k);
+                ShortArrayList shortarraylist = new ShortArrayList(nbttaglist1.size());
 
-                for (int j = 0; j < listTag2.size(); j++) {
-                    shortList.add(listTag2.getShort(j));
+                for (int l = 0; l < nbttaglist1.size(); ++l) {
+                    shortarraylist.add(nbttaglist1.getShort(l));
                 }
 
-                shortLists[i] = shortList;
+                ashortlist[k] = shortarraylist;
             }
 
-            List<CompoundTag> list3 = Lists.transform(nbt.getList("entities", 10), entity -> (CompoundTag)entity);
-            List<CompoundTag> list4 = Lists.transform(nbt.getList("block_entities", 10), blockEntity -> (CompoundTag)blockEntity);
-            CompoundTag compoundTag2 = nbt.getCompound("structures");
-            ListTag listTag3 = nbt.getList("sections", 10);
-            List<SerializableChunkData.SectionData> list5 = new ArrayList<>(listTag3.size());
-            Registry<Biome> registry = registryManager.lookupOrThrow(Registries.BIOME);
-            Codec<PalettedContainerRO<Holder<Biome>>> codec = makeBiomeCodec(registry);
+            List<CompoundTag> list2 = Lists.transform(nbt.getList("entities", 10), (nbtbase) -> {
+                return (CompoundTag) nbtbase;
+            });
+            List<CompoundTag> list3 = Lists.transform(nbt.getList("block_entities", 10), (nbtbase) -> {
+                return (CompoundTag) nbtbase;
+            });
+            CompoundTag nbttagcompound2 = nbt.getCompound("structures");
+            ListTag nbttaglist2 = nbt.getList("sections", 10);
+            List<SerializableChunkData.SectionData> list4 = new ArrayList(nbttaglist2.size());
+            Registry<Biome> iregistry = registryManager.lookupOrThrow(Registries.BIOME);
+            Codec<PalettedContainer<Holder<Biome>>> codec = makeBiomeCodecRW(iregistry); // CraftBukkit - read/write
 
-            for (int k = 0; k < listTag3.size(); k++) {
-                CompoundTag compoundTag3 = listTag3.getCompound(k);
-                int n = compoundTag3.getByte("Y");
-                LevelChunkSection levelChunkSection;
-                if (n >= world.getMinSectionY() && n <= world.getMaxSectionY()) {
-                    PalettedContainer<BlockState> palettedContainer;
-                    if (compoundTag3.contains("block_states", 10)) {
-                        palettedContainer = BLOCK_STATE_CODEC.parse(NbtOps.INSTANCE, compoundTag3.getCompound("block_states"))
-                            .promotePartial(error -> logErrors(chunkPos, n, error))
-                            .getOrThrow(SerializableChunkData.ChunkReadException::new);
+            for (int i1 = 0; i1 < nbttaglist2.size(); ++i1) {
+                CompoundTag nbttagcompound3 = nbttaglist2.getCompound(i1); final CompoundTag sectionData = nbttagcompound3; // Paper - Anti-Xray - OBFHELPER
+                byte b0 = nbttagcompound3.getByte("Y");
+                LevelChunkSection chunksection;
+
+                if (b0 >= world.getMinSectionY() && b0 <= world.getMaxSectionY()) {
+                    PalettedContainer datapaletteblock;
+                    // Paper start - Anti-Xray - Add preset block states
+                    BlockState[] presetBlockStates = serverLevel.chunkPacketBlockController.getPresetBlockStates(serverLevel, chunkcoordintpair, b0);
+
+
+                    if (nbttagcompound3.contains("block_states", 10)) {
+                        Codec<PalettedContainer<BlockState>> blockStateCodec = presetBlockStates == null ? BLOCK_STATE_CODEC : PalettedContainer.codecRW(Block.BLOCK_STATE_REGISTRY, BlockState.CODEC, PalettedContainer.Strategy.SECTION_STATES, Blocks.AIR.defaultBlockState(), presetBlockStates); // Paper - Anti-Xray
+                        datapaletteblock = blockStateCodec.parse(NbtOps.INSTANCE, sectionData.getCompound("block_states")).promotePartial((s1) -> { // Paper - Anti-Xray
+                            logErrors(chunkcoordintpair, b0, s1);
+                        }).getOrThrow(SerializableChunkData.ChunkReadException::new);
                     } else {
-                        palettedContainer = new PalettedContainer<>(
-                            Block.BLOCK_STATE_REGISTRY, Blocks.AIR.defaultBlockState(), PalettedContainer.Strategy.SECTION_STATES
-                        );
+                        datapaletteblock = new PalettedContainer<>(Block.BLOCK_STATE_REGISTRY, Blocks.AIR.defaultBlockState(), PalettedContainer.Strategy.SECTION_STATES, presetBlockStates); // Paper - Anti-Xray
                     }
 
-                    PalettedContainerRO<Holder<Biome>> palettedContainerRO;
-                    if (compoundTag3.contains("biomes", 10)) {
-                        palettedContainerRO = codec.parse(NbtOps.INSTANCE, compoundTag3.getCompound("biomes"))
-                            .promotePartial(error -> logErrors(chunkPos, n, error))
-                            .getOrThrow(SerializableChunkData.ChunkReadException::new);
+                    PalettedContainer object; // CraftBukkit - read/write
+
+                    if (nbttagcompound3.contains("biomes", 10)) {
+                        object = codec.parse(NbtOps.INSTANCE, nbttagcompound3.getCompound("biomes")).promotePartial((s1) -> { // CraftBukkit - read/write
+                            logErrors(chunkcoordintpair, b0, s1);
+                        }).getOrThrow(SerializableChunkData.ChunkReadException::new);
                     } else {
-                        palettedContainerRO = new PalettedContainer<>(
-                            registry.asHolderIdMap(), registry.getOrThrow(Biomes.PLAINS), PalettedContainer.Strategy.SECTION_BIOMES
-                        );
+                        object = new PalettedContainer<>(iregistry.asHolderIdMap(), iregistry.getOrThrow(Biomes.PLAINS), PalettedContainer.Strategy.SECTION_BIOMES, null);  // Paper - Anti-Xray - Add preset biomes
                     }
 
-                    levelChunkSection = new LevelChunkSection(palettedContainer, palettedContainerRO);
+                    chunksection = new LevelChunkSection(datapaletteblock, (PalettedContainer) object); // CraftBukkit - read/write
                 } else {
-                    levelChunkSection = null;
+                    chunksection = null;
                 }
 
-                DataLayer dataLayer = compoundTag3.contains("BlockLight", 7) ? new DataLayer(compoundTag3.getByteArray("BlockLight")) : null;
-                DataLayer dataLayer2 = compoundTag3.contains("SkyLight", 7) ? new DataLayer(compoundTag3.getByteArray("SkyLight")) : null;
-                list5.add(new SerializableChunkData.SectionData(n, levelChunkSection, dataLayer, dataLayer2));
+                DataLayer nibblearray = nbttagcompound3.contains("BlockLight", 7) ? new DataLayer(nbttagcompound3.getByteArray("BlockLight")) : null;
+                DataLayer nibblearray1 = nbttagcompound3.contains("SkyLight", 7) ? new DataLayer(nbttagcompound3.getByteArray("SkyLight")) : null;
+
+                // Paper start - starlight
+                SerializableChunkData.SectionData serializableChunkData = new SerializableChunkData.SectionData(b0, chunksection, nibblearray, nibblearray1);
+                if (sectionData.contains(ca.spottedleaf.moonrise.patches.starlight.util.SaveUtil.BLOCKLIGHT_STATE_TAG, Tag.TAG_ANY_NUMERIC)) {
+                    ((ca.spottedleaf.moonrise.patches.starlight.storage.StarlightSectionData)(Object)serializableChunkData).starlight$setBlockLightState(sectionData.getInt(ca.spottedleaf.moonrise.patches.starlight.util.SaveUtil.BLOCKLIGHT_STATE_TAG));
+                }
+
+                if (sectionData.contains(ca.spottedleaf.moonrise.patches.starlight.util.SaveUtil.SKYLIGHT_STATE_TAG, Tag.TAG_ANY_NUMERIC)) {
+                    ((ca.spottedleaf.moonrise.patches.starlight.storage.StarlightSectionData)(Object)serializableChunkData).starlight$setSkyLightState(sectionData.getInt(ca.spottedleaf.moonrise.patches.starlight.util.SaveUtil.SKYLIGHT_STATE_TAG));
+                }
+                list4.add(serializableChunkData);
+                // Paper end - starlight
             }
 
-            return new SerializableChunkData(
-                registry,
-                chunkPos,
-                world.getMinSectionY(),
-                l,
-                m,
-                chunkStatus,
-                packed,
-                belowZeroRetrogen,
-                upgradeData,
-                ls,
-                map,
-                packedTicks,
-                shortLists,
-                bl,
-                list5,
-                list3,
-                list4,
-                compoundTag2
-            );
+            // CraftBukkit - ChunkBukkitValues
+            return new SerializableChunkData(iregistry, chunkcoordintpair, world.getMinSectionY(), i, j, chunkstatus, blendingdata_d, belowzeroretrogen, chunkconverter, along, map, ichunkaccess_a, ashortlist, flag, list4, list2, list3, nbttagcompound2, nbt.get("ChunkBukkitValues"));
+        }
+    }
+
+    // Paper start - starlight
+    private ProtoChunk loadStarlightLightData(final ServerLevel world, final ProtoChunk ret) {
+
+        final boolean hasSkyLight = world.dimensionType().hasSkyLight();
+        final int minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinLightSection(world);
+
+        final ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray[] blockNibbles = ca.spottedleaf.moonrise.patches.starlight.light.StarLightEngine.getFilledEmptyLight(world);
+        final ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray[] skyNibbles = ca.spottedleaf.moonrise.patches.starlight.light.StarLightEngine.getFilledEmptyLight(world);
+
+        if (!this.lightCorrect) {
+            ((ca.spottedleaf.moonrise.patches.starlight.chunk.StarlightChunk)ret).starlight$setBlockNibbles(blockNibbles);
+            ((ca.spottedleaf.moonrise.patches.starlight.chunk.StarlightChunk)ret).starlight$setSkyNibbles(skyNibbles);
+            return ret;
+        }
+
+        try {
+            for (final SerializableChunkData.SectionData sectionData : this.sectionData) {
+                final int y = sectionData.y();
+                final DataLayer blockLight = sectionData.blockLight();
+                final DataLayer skyLight = sectionData.skyLight();
+
+                final int blockState = ((ca.spottedleaf.moonrise.patches.starlight.storage.StarlightSectionData)(Object)sectionData).starlight$getBlockLightState();
+                final int skyState = ((ca.spottedleaf.moonrise.patches.starlight.storage.StarlightSectionData)(Object)sectionData).starlight$getSkyLightState();
+
+                if (blockState >= 0) {
+                    if (blockLight != null) {
+                        blockNibbles[y - minSection] = new ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray(ca.spottedleaf.moonrise.common.util.MixinWorkarounds.clone(blockLight.getData()), blockState); // clone for data safety
+                    } else {
+                        blockNibbles[y - minSection] = new ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray(null, blockState);
+                    }
+                }
+
+                if (skyState >= 0 && hasSkyLight) {
+                    if (skyLight != null) {
+                        skyNibbles[y - minSection] = new ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray(ca.spottedleaf.moonrise.common.util.MixinWorkarounds.clone(skyLight.getData()), skyState); // clone for data safety
+                    } else {
+                        skyNibbles[y - minSection] = new ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray(null, skyState);
+                    }
+                }
+            }
+
+            ((ca.spottedleaf.moonrise.patches.starlight.chunk.StarlightChunk)ret).starlight$setBlockNibbles(blockNibbles);
+            ((ca.spottedleaf.moonrise.patches.starlight.chunk.StarlightChunk)ret).starlight$setSkyNibbles(skyNibbles);
+        } catch (final Throwable thr) {
+            ret.setLightCorrect(false);
+
+            LOGGER.error("Failed to parse light data for chunk " + ret.getPos() + " in world '" + ca.spottedleaf.moonrise.common.util.WorldUtil.getWorldName(world) + "'", thr);
         }
+
+        return ret;
     }
+    // Paper end - starlight
 
     public ProtoChunk read(ServerLevel world, PoiManager poiStorage, RegionStorageInfo key, ChunkPos expectedPos) {
         if (!Objects.equals(expectedPos, this.chunkPos)) {
-            LOGGER.error("Chunk file at {} is in the wrong location; relocating. (Expected {}, got {})", expectedPos, expectedPos, this.chunkPos);
+            SerializableChunkData.LOGGER.error("Chunk file at {} is in the wrong location; relocating. (Expected {}, got {})", new Object[]{expectedPos, expectedPos, this.chunkPos});
             world.getServer().reportMisplacedChunk(this.chunkPos, expectedPos, key);
         }
 
         int i = world.getSectionsCount();
-        LevelChunkSection[] levelChunkSections = new LevelChunkSection[i];
-        boolean bl = world.dimensionType().hasSkyLight();
-        ChunkSource chunkSource = world.getChunkSource();
-        LevelLightEngine levelLightEngine = chunkSource.getLightEngine();
-        Registry<Biome> registry = world.registryAccess().lookupOrThrow(Registries.BIOME);
-        boolean bl2 = false;
+        LevelChunkSection[] achunksection = new LevelChunkSection[i];
+        boolean flag = world.dimensionType().hasSkyLight();
+        ServerChunkCache chunkproviderserver = world.getChunkSource();
+        LevelLightEngine levellightengine = chunkproviderserver.getLightEngine();
+        Registry<Biome> iregistry = world.registryAccess().lookupOrThrow(Registries.BIOME);
+        boolean flag1 = false;
+        Iterator iterator = this.sectionData.iterator();
 
-        for (SerializableChunkData.SectionData sectionData : this.sectionData) {
-            SectionPos sectionPos = SectionPos.of(expectedPos, sectionData.y);
-            if (sectionData.chunkSection != null) {
-                levelChunkSections[world.getSectionIndexFromSectionY(sectionData.y)] = sectionData.chunkSection;
-                poiStorage.checkConsistencyWithBlocks(sectionPos, sectionData.chunkSection);
+        while (iterator.hasNext()) {
+            SerializableChunkData.SectionData serializablechunkdata_b = (SerializableChunkData.SectionData) iterator.next();
+            SectionPos sectionposition = SectionPos.of(expectedPos, serializablechunkdata_b.y);
+
+            if (serializablechunkdata_b.chunkSection != null) {
+                achunksection[world.getSectionIndexFromSectionY(serializablechunkdata_b.y)] = serializablechunkdata_b.chunkSection;
+                //poiStorage.checkConsistencyWithBlocks(sectionposition, serializablechunkdata_b.chunkSection); // Paper - rewrite chunk system
             }
 
-            boolean bl3 = sectionData.blockLight != null;
-            boolean bl4 = bl && sectionData.skyLight != null;
-            if (bl3 || bl4) {
-                if (!bl2) {
-                    levelLightEngine.retainData(expectedPos, true);
-                    bl2 = true;
+            boolean flag2 = serializablechunkdata_b.blockLight != null;
+            boolean flag3 = flag && serializablechunkdata_b.skyLight != null;
+
+            if (flag2 || flag3) {
+                if (!flag1) {
+                    levellightengine.retainData(expectedPos, true);
+                    flag1 = true;
                 }
 
-                if (bl3) {
-                    levelLightEngine.queueSectionData(LightLayer.BLOCK, sectionPos, sectionData.blockLight);
+                if (flag2) {
+                    levellightengine.queueSectionData(LightLayer.BLOCK, sectionposition, serializablechunkdata_b.blockLight);
                 }
 
-                if (bl4) {
-                    levelLightEngine.queueSectionData(LightLayer.SKY, sectionPos, sectionData.skyLight);
+                if (flag3) {
+                    levellightengine.queueSectionData(LightLayer.SKY, sectionposition, serializablechunkdata_b.skyLight);
                 }
             }
         }
 
-        ChunkType chunkType = this.chunkStatus.getChunkType();
-        ChunkAccess chunkAccess;
-        if (chunkType == ChunkType.LEVELCHUNK) {
-            LevelChunkTicks<Block> levelChunkTicks = new LevelChunkTicks<>(this.packedTicks.blocks());
-            LevelChunkTicks<Fluid> levelChunkTicks2 = new LevelChunkTicks<>(this.packedTicks.fluids());
-            chunkAccess = new LevelChunk(
-                world.getLevel(),
-                expectedPos,
-                this.upgradeData,
-                levelChunkTicks,
-                levelChunkTicks2,
-                this.inhabitedTime,
-                levelChunkSections,
-                postLoadChunk(world, this.entities, this.blockEntities),
-                BlendingData.unpack(this.blendingData)
-            );
+        ChunkType chunktype = this.chunkStatus.getChunkType();
+        Object object;
+
+        if (chunktype == ChunkType.LEVELCHUNK) {
+            LevelChunkTicks<Block> levelchunkticks = new LevelChunkTicks<>(this.packedTicks.blocks());
+            LevelChunkTicks<Fluid> levelchunkticks1 = new LevelChunkTicks<>(this.packedTicks.fluids());
+
+            object = new LevelChunk(world.getLevel(), expectedPos, this.upgradeData, levelchunkticks, levelchunkticks1, this.inhabitedTime, achunksection, postLoadChunk(world, this.entities, this.blockEntities), BlendingData.unpack(this.blendingData));
         } else {
-            ProtoChunkTicks<Block> protoChunkTicks = ProtoChunkTicks.load(this.packedTicks.blocks());
-            ProtoChunkTicks<Fluid> protoChunkTicks2 = ProtoChunkTicks.load(this.packedTicks.fluids());
-            ProtoChunk protoChunk = new ProtoChunk(
-                expectedPos, this.upgradeData, levelChunkSections, protoChunkTicks, protoChunkTicks2, world, registry, BlendingData.unpack(this.blendingData)
-            );
-            chunkAccess = protoChunk;
-            protoChunk.setInhabitedTime(this.inhabitedTime);
+            ProtoChunkTicks<Block> protochunkticklist = ProtoChunkTicks.load(this.packedTicks.blocks());
+            ProtoChunkTicks<Fluid> protochunkticklist1 = ProtoChunkTicks.load(this.packedTicks.fluids());
+            ProtoChunk protochunk = new ProtoChunk(expectedPos, this.upgradeData, achunksection, protochunkticklist, protochunkticklist1, world, iregistry, BlendingData.unpack(this.blendingData));
+
+            object = protochunk;
+            protochunk.setInhabitedTime(this.inhabitedTime);
             if (this.belowZeroRetrogen != null) {
-                protoChunk.setBelowZeroRetrogen(this.belowZeroRetrogen);
+                protochunk.setBelowZeroRetrogen(this.belowZeroRetrogen);
             }
 
-            protoChunk.setPersistedStatus(this.chunkStatus);
+            protochunk.setPersistedStatus(this.chunkStatus);
             if (this.chunkStatus.isOrAfter(ChunkStatus.INITIALIZE_LIGHT)) {
-                protoChunk.setLightEngine(levelLightEngine);
+                protochunk.setLightEngine(levellightengine);
             }
         }
 
-        chunkAccess.setLightCorrect(this.lightCorrect);
-        EnumSet<Heightmap.Types> enumSet = EnumSet.noneOf(Heightmap.Types.class);
+        // CraftBukkit start - load chunk persistent data from nbt - SPIGOT-6814: Already load PDC here to account for 1.17 to 1.18 chunk upgrading.
+        if (this.persistentDataContainer instanceof CompoundTag) {
+            ((ChunkAccess) object).persistentDataContainer.putAll((CompoundTag) this.persistentDataContainer);
+        }
+        // CraftBukkit end
 
-        for (Heightmap.Types types : chunkAccess.getPersistedStatus().heightmapsAfter()) {
-            long[] ls = this.heightmaps.get(types);
-            if (ls != null) {
-                chunkAccess.setHeightmap(types, ls);
+        ((ChunkAccess) object).setLightCorrect(this.lightCorrect);
+        EnumSet<Heightmap.Types> enumset = EnumSet.noneOf(Heightmap.Types.class);
+        Iterator iterator1 = ((ChunkAccess) object).getPersistedStatus().heightmapsAfter().iterator();
+
+        while (iterator1.hasNext()) {
+            Heightmap.Types heightmap_type = (Heightmap.Types) iterator1.next();
+            long[] along = (long[]) this.heightmaps.get(heightmap_type);
+
+            if (along != null) {
+                ((ChunkAccess) object).setHeightmap(heightmap_type, along);
             } else {
-                enumSet.add(types);
+                enumset.add(heightmap_type);
             }
         }
 
-        Heightmap.primeHeightmaps(chunkAccess, enumSet);
-        chunkAccess.setAllStarts(unpackStructureStart(StructurePieceSerializationContext.fromLevel(world), this.structureData, world.getSeed()));
-        chunkAccess.setAllReferences(unpackStructureReferences(world.registryAccess(), expectedPos, this.structureData));
+        Heightmap.primeHeightmaps((ChunkAccess) object, enumset);
+        ((ChunkAccess) object).setAllStarts(unpackStructureStart(StructurePieceSerializationContext.fromLevel(world), this.structureData, world.getSeed()));
+        ((ChunkAccess) object).setAllReferences(unpackStructureReferences(world.registryAccess(), expectedPos, this.structureData));
 
-        for (int j = 0; j < this.postProcessingSections.length; j++) {
-            chunkAccess.addPackedPostProcess(this.postProcessingSections[j], j);
+        for (int j = 0; j < this.postProcessingSections.length; ++j) {
+            ((ChunkAccess) object).addPackedPostProcess(this.postProcessingSections[j], j);
         }
 
-        if (chunkType == ChunkType.LEVELCHUNK) {
-            return new ImposterProtoChunk((LevelChunk)chunkAccess, false);
+        if (chunktype == ChunkType.LEVELCHUNK) {
+            return this.loadStarlightLightData(world, new ImposterProtoChunk((LevelChunk) object, false)); // Paper - starlight
         } else {
-            ProtoChunk protoChunk2 = (ProtoChunk)chunkAccess;
+            ProtoChunk protochunk1 = (ProtoChunk) object;
+            Iterator iterator2 = this.entities.iterator();
 
-            for (CompoundTag compoundTag : this.entities) {
-                protoChunk2.addEntity(compoundTag);
+            CompoundTag nbttagcompound;
+
+            while (iterator2.hasNext()) {
+                nbttagcompound = (CompoundTag) iterator2.next();
+                protochunk1.addEntity(nbttagcompound);
             }
 
-            for (CompoundTag compoundTag2 : this.blockEntities) {
-                protoChunk2.setBlockEntityNbt(compoundTag2);
+            iterator2 = this.blockEntities.iterator();
+
+            while (iterator2.hasNext()) {
+                nbttagcompound = (CompoundTag) iterator2.next();
+                // Paper start - do not read tile entities positioned outside the chunk
+                final BlockPos blockposition = BlockEntity.getPosFromTag(nbttagcompound);
+                if ((blockposition.getX() >> 4) != chunkPos.x || (blockposition.getZ() >> 4) != chunkPos.z) {
+                    LOGGER.warn("Tile entity serialized in chunk {} in world '{}' positioned at {} is located outside of the chunk", chunkPos, world.getWorld().getName(), blockposition);
+                    continue;
+                }
+                // Paper end - do not read tile entities positioned outside the chunk
+                protochunk1.setBlockEntityNbt(nbttagcompound);
             }
 
             if (this.carvingMask != null) {
-                protoChunk2.setCarvingMask(new CarvingMask(this.carvingMask, chunkAccess.getMinY()));
+                protochunk1.setCarvingMask(new CarvingMask(this.carvingMask, ((ChunkAccess) object).getMinY()));
             }
 
-            return protoChunk2;
+            return this.loadStarlightLightData(world, protochunk1); // Paper - starlight
         }
     }
 
     private static void logErrors(ChunkPos chunkPos, int y, String message) {
-        LOGGER.error("Recoverable errors when loading section [{}, {}, {}]: {}", chunkPos.x, y, chunkPos.z, message);
+        SerializableChunkData.LOGGER.error("Recoverable errors when loading section [{}, {}, {}]: {}", new Object[]{chunkPos.x, y, chunkPos.z, message});
     }
 
     private static Codec<PalettedContainerRO<Holder<Biome>>> makeBiomeCodec(Registry<Biome> biomeRegistry) {
-        return PalettedContainer.codecRO(
-            biomeRegistry.asHolderIdMap(),
-            biomeRegistry.holderByNameCodec(),
-            PalettedContainer.Strategy.SECTION_BIOMES,
-            biomeRegistry.getOrThrow(Biomes.PLAINS)
-        );
+        return PalettedContainer.codecRO(biomeRegistry.asHolderIdMap(), biomeRegistry.holderByNameCodec(), PalettedContainer.Strategy.SECTION_BIOMES, biomeRegistry.getOrThrow(Biomes.PLAINS));
     }
 
+    // CraftBukkit start - read/write
+    private static Codec<PalettedContainer<Holder<Biome>>> makeBiomeCodecRW(Registry<Biome> iregistry) {
+        return PalettedContainer.codecRW(iregistry.asHolderIdMap(), iregistry.holderByNameCodec(), PalettedContainer.Strategy.SECTION_BIOMES, iregistry.getOrThrow(Biomes.PLAINS), null); // Paper - Anti-Xray - Add preset biomes
+    }
+    // CraftBukkit end
+
     public static SerializableChunkData copyOf(ServerLevel world, ChunkAccess chunk) {
         if (!chunk.canBeSerialized()) {
-            throw new IllegalArgumentException("Chunk can't be serialized: " + chunk);
+            throw new IllegalArgumentException("Chunk can't be serialized: " + String.valueOf(chunk));
         } else {
-            ChunkPos chunkPos = chunk.getPos();
-            List<SerializableChunkData.SectionData> list = new ArrayList<>();
-            LevelChunkSection[] levelChunkSections = chunk.getSections();
-            LevelLightEngine levelLightEngine = world.getChunkSource().getLightEngine();
+            ChunkPos chunkcoordintpair = chunk.getPos();
+            List<SerializableChunkData.SectionData> list = new ArrayList(); final List<SerializableChunkData.SectionData> sections = list; // Paper - starlight - OBFHELPER
+            LevelChunkSection[] achunksection = chunk.getSections();
+            ThreadedLevelLightEngine lightenginethreaded = world.getChunkSource().getLightEngine();
 
-            for (int i = levelLightEngine.getMinLightSection(); i < levelLightEngine.getMaxLightSection(); i++) {
-                int j = chunk.getSectionIndexFromSectionY(i);
-                boolean bl = j >= 0 && j < levelChunkSections.length;
-                DataLayer dataLayer = levelLightEngine.getLayerListener(LightLayer.BLOCK).getDataLayerData(SectionPos.of(chunkPos, i));
-                DataLayer dataLayer2 = levelLightEngine.getLayerListener(LightLayer.SKY).getDataLayerData(SectionPos.of(chunkPos, i));
-                DataLayer dataLayer3 = dataLayer != null && !dataLayer.isEmpty() ? dataLayer.copy() : null;
-                DataLayer dataLayer4 = dataLayer2 != null && !dataLayer2.isEmpty() ? dataLayer2.copy() : null;
-                if (bl || dataLayer3 != null || dataLayer4 != null) {
-                    LevelChunkSection levelChunkSection = bl ? levelChunkSections[j].copy() : null;
-                    list.add(new SerializableChunkData.SectionData(i, levelChunkSection, dataLayer3, dataLayer4));
+            // Paper start - starlight
+            final int minLightSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinLightSection(world);
+            final int maxLightSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMaxLightSection(world);
+            final int minBlockSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection(world);
+
+            final LevelChunkSection[] chunkSections = chunk.getSections();
+            final ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray[] blockNibbles = ((ca.spottedleaf.moonrise.patches.starlight.chunk.StarlightChunk)chunk).starlight$getBlockNibbles();
+            final ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray[] skyNibbles = ((ca.spottedleaf.moonrise.patches.starlight.chunk.StarlightChunk)chunk).starlight$getSkyNibbles();
+
+            for (int lightSection = minLightSection; lightSection <= maxLightSection; ++lightSection) {
+                final int lightSectionIdx = lightSection - minLightSection;
+                final int blockSectionIdx = lightSection - minBlockSection;
+
+                final LevelChunkSection chunkSection = (blockSectionIdx >= 0 && blockSectionIdx < chunkSections.length) ? chunkSections[blockSectionIdx].copy() : null;
+                final ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray.SaveState blockNibble = blockNibbles[lightSectionIdx].getSaveState();
+                final ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray.SaveState skyNibble = skyNibbles[lightSectionIdx].getSaveState();
+
+                if (chunkSection == null && blockNibble == null && skyNibble == null) {
+                    continue;
                 }
+
+                final SerializableChunkData.SectionData sectionData = new SerializableChunkData.SectionData(
+                    lightSection, chunkSection,
+                    blockNibble == null ? null : (blockNibble.data == null ? null : new DataLayer(blockNibble.data)),
+                    skyNibble == null ? null : (skyNibble.data == null ? null : new DataLayer(skyNibble.data))
+                );
+
+                if (blockNibble != null) {
+                    ((ca.spottedleaf.moonrise.patches.starlight.storage.StarlightSectionData)(Object)sectionData).starlight$setBlockLightState(blockNibble.state);
+                }
+
+                if (skyNibble != null) {
+                    ((ca.spottedleaf.moonrise.patches.starlight.storage.StarlightSectionData)(Object)sectionData).starlight$setSkyLightState(skyNibble.state);
+                }
+
+                sections.add(sectionData);
             }
+            // Paper end - starlight
 
-            List<CompoundTag> list2 = new ArrayList<>(chunk.getBlockEntitiesPos().size());
+            List<CompoundTag> list1 = new ArrayList(chunk.getBlockEntitiesPos().size());
+            Iterator iterator = chunk.getBlockEntitiesPos().iterator();
 
-            for (BlockPos blockPos : chunk.getBlockEntitiesPos()) {
-                CompoundTag compoundTag = chunk.getBlockEntityNbtForSaving(blockPos, world.registryAccess());
-                if (compoundTag != null) {
-                    list2.add(compoundTag);
+            while (iterator.hasNext()) {
+                BlockPos blockposition = (BlockPos) iterator.next();
+                CompoundTag nbttagcompound = chunk.getBlockEntityNbtForSaving(blockposition, world.registryAccess());
+
+                if (nbttagcompound != null) {
+                    list1.add(nbttagcompound);
                 }
             }
 
-            List<CompoundTag> list3 = new ArrayList<>();
-            long[] ls = null;
+            List<CompoundTag> list2 = new ArrayList();
+            long[] along = null;
+
             if (chunk.getPersistedStatus().getChunkType() == ChunkType.PROTOCHUNK) {
-                ProtoChunk protoChunk = (ProtoChunk)chunk;
-                list3.addAll(protoChunk.getEntities());
-                CarvingMask carvingMask = protoChunk.getCarvingMask();
-                if (carvingMask != null) {
-                    ls = carvingMask.toArray();
+                ProtoChunk protochunk = (ProtoChunk) chunk;
+
+                list2.addAll(protochunk.getEntities());
+                CarvingMask carvingmask = protochunk.getCarvingMask();
+
+                if (carvingmask != null) {
+                    along = carvingmask.toArray();
                 }
             }
 
-            Map<Heightmap.Types, long[]> map = new EnumMap<>(Heightmap.Types.class);
+            Map<Heightmap.Types, long[]> map = new EnumMap(Heightmap.Types.class);
+            Iterator iterator1 = chunk.getHeightmaps().iterator();
+
+            while (iterator1.hasNext()) {
+                Entry<Heightmap.Types, Heightmap> entry = (Entry) iterator1.next();
 
-            for (Entry<Heightmap.Types, Heightmap> entry : chunk.getHeightmaps()) {
                 if (chunk.getPersistedStatus().heightmapsAfter().contains(entry.getKey())) {
-                    long[] ms = entry.getValue().getRawData();
-                    map.put(entry.getKey(), (long[])ms.clone());
+                    long[] along1 = ((Heightmap) entry.getValue()).getRawData();
+
+                    map.put((Heightmap.Types) entry.getKey(), (long[]) along1.clone());
                 }
             }
 
-            ChunkAccess.PackedTicks packedTicks = chunk.getTicksForSerialization(world.getGameTime());
-            ShortList[] shortLists = Arrays.stream(chunk.getPostProcessing())
-                .map(postProcessings -> postProcessings != null ? new ShortArrayList(postProcessings) : null)
-                .toArray(ShortList[]::new);
-            CompoundTag compoundTag2 = packStructureData(
-                StructurePieceSerializationContext.fromLevel(world), chunkPos, chunk.getAllStarts(), chunk.getAllReferences()
-            );
-            return new SerializableChunkData(
-                world.registryAccess().lookupOrThrow(Registries.BIOME),
-                chunkPos,
-                chunk.getMinSectionY(),
-                world.getGameTime(),
-                chunk.getInhabitedTime(),
-                chunk.getPersistedStatus(),
-                Optionull.map(chunk.getBlendingData(), BlendingData::pack),
-                chunk.getBelowZeroRetrogen(),
-                chunk.getUpgradeData().copy(),
-                ls,
-                map,
-                packedTicks,
-                shortLists,
-                chunk.isLightCorrect(),
-                list,
-                list3,
-                list2,
-                compoundTag2
-            );
+            ChunkAccess.PackedTicks ichunkaccess_a = chunk.getTicksForSerialization(world.getGameTime());
+            ShortList[] ashortlist = (ShortList[]) Arrays.stream(chunk.getPostProcessing()).map((shortlist) -> {
+                return shortlist != null ? new ShortArrayList(shortlist) : null;
+            }).toArray((k) -> {
+                return new ShortList[k];
+            });
+            CompoundTag nbttagcompound1 = packStructureData(StructurePieceSerializationContext.fromLevel(world), chunkcoordintpair, chunk.getAllStarts(), chunk.getAllReferences());
+
+            // CraftBukkit start - store chunk persistent data in nbt
+            CompoundTag persistentDataContainer = null;
+            if (!chunk.persistentDataContainer.isEmpty()) { // SPIGOT-6814: Always save PDC to account for 1.17 to 1.18 chunk upgrading.
+                persistentDataContainer = chunk.persistentDataContainer.toTagCompound();
+            }
+
+            return new SerializableChunkData(world.registryAccess().lookupOrThrow(Registries.BIOME), chunkcoordintpair, chunk.getMinSectionY(), world.getGameTime(), chunk.getInhabitedTime(), chunk.getPersistedStatus(), (BlendingData.Packed) Optionull.map(chunk.getBlendingData(), BlendingData::pack), chunk.getBelowZeroRetrogen(), chunk.getUpgradeData().copy(), along, map, ichunkaccess_a, ashortlist, chunk.isLightCorrect(), list, list2, list1, nbttagcompound1, persistentDataContainer);
+            // CraftBukkit end
         }
     }
 
     public CompoundTag write() {
-        CompoundTag compoundTag = NbtUtils.addCurrentDataVersion(new CompoundTag());
-        compoundTag.putInt("xPos", this.chunkPos.x);
-        compoundTag.putInt("yPos", this.minSectionY);
-        compoundTag.putInt("zPos", this.chunkPos.z);
-        compoundTag.putLong("LastUpdate", this.lastUpdateTime);
-        compoundTag.putLong("InhabitedTime", this.inhabitedTime);
-        compoundTag.putString("Status", BuiltInRegistries.CHUNK_STATUS.getKey(this.chunkStatus).toString());
+        CompoundTag nbttagcompound = NbtUtils.addCurrentDataVersion(new CompoundTag());
+
+        nbttagcompound.putInt("xPos", this.chunkPos.x);
+        nbttagcompound.putInt("yPos", this.minSectionY);
+        nbttagcompound.putInt("zPos", this.chunkPos.z);
+        nbttagcompound.putLong("LastUpdate", this.lastUpdateTime); // Paper - Diff on change
+        nbttagcompound.putLong("InhabitedTime", this.inhabitedTime);
+        nbttagcompound.putString("Status", BuiltInRegistries.CHUNK_STATUS.getKey(this.chunkStatus).toString());
+        DataResult<Tag> dataresult; // CraftBukkit - decompile error
+        Logger logger;
+
         if (this.blendingData != null) {
-            BlendingData.Packed.CODEC
-                .encodeStart(NbtOps.INSTANCE, this.blendingData)
-                .resultOrPartial(LOGGER::error)
-                .ifPresent(blendingData -> compoundTag.put("blending_data", blendingData));
+            dataresult = BlendingData.Packed.CODEC.encodeStart(NbtOps.INSTANCE, this.blendingData);
+            logger = SerializableChunkData.LOGGER;
+            Objects.requireNonNull(logger);
+            dataresult.resultOrPartial(logger::error).ifPresent((nbtbase) -> {
+                nbttagcompound.put("blending_data", nbtbase);
+            });
         }
 
         if (this.belowZeroRetrogen != null) {
-            BelowZeroRetrogen.CODEC
-                .encodeStart(NbtOps.INSTANCE, this.belowZeroRetrogen)
-                .resultOrPartial(LOGGER::error)
-                .ifPresent(belowZeroRetrogen -> compoundTag.put("below_zero_retrogen", belowZeroRetrogen));
+            dataresult = BelowZeroRetrogen.CODEC.encodeStart(NbtOps.INSTANCE, this.belowZeroRetrogen);
+            logger = SerializableChunkData.LOGGER;
+            Objects.requireNonNull(logger);
+            dataresult.resultOrPartial(logger::error).ifPresent((nbtbase) -> {
+                nbttagcompound.put("below_zero_retrogen", nbtbase);
+            });
         }
 
         if (!this.upgradeData.isEmpty()) {
-            compoundTag.put("UpgradeData", this.upgradeData.write());
+            nbttagcompound.put("UpgradeData", this.upgradeData.write());
         }
 
-        ListTag listTag = new ListTag();
+        ListTag nbttaglist = new ListTag();
         Codec<PalettedContainerRO<Holder<Biome>>> codec = makeBiomeCodec(this.biomeRegistry);
+        Iterator iterator = this.sectionData.iterator();
 
-        for (SerializableChunkData.SectionData sectionData : this.sectionData) {
-            CompoundTag compoundTag2 = new CompoundTag();
-            LevelChunkSection levelChunkSection = sectionData.chunkSection;
-            if (levelChunkSection != null) {
-                compoundTag2.put("block_states", BLOCK_STATE_CODEC.encodeStart(NbtOps.INSTANCE, levelChunkSection.getStates()).getOrThrow());
-                compoundTag2.put("biomes", codec.encodeStart(NbtOps.INSTANCE, levelChunkSection.getBiomes()).getOrThrow());
+        while (iterator.hasNext()) {
+            SerializableChunkData.SectionData serializablechunkdata_b = (SerializableChunkData.SectionData) iterator.next(); final SerializableChunkData.SectionData sectionData = serializablechunkdata_b; // Paper - starlight - OBFHELPER
+            CompoundTag nbttagcompound1 = new CompoundTag(); final CompoundTag sectionNBT = nbttagcompound1; // Paper - starlight - OBFHELPER
+            LevelChunkSection chunksection = serializablechunkdata_b.chunkSection;
+
+            if (chunksection != null) {
+                nbttagcompound1.put("block_states", (Tag) SerializableChunkData.BLOCK_STATE_CODEC.encodeStart(NbtOps.INSTANCE, chunksection.getStates()).getOrThrow());
+                nbttagcompound1.put("biomes", (Tag) codec.encodeStart(NbtOps.INSTANCE, chunksection.getBiomes()).getOrThrow());
             }
 
-            if (sectionData.blockLight != null) {
-                compoundTag2.putByteArray("BlockLight", sectionData.blockLight.getData());
+            if (serializablechunkdata_b.blockLight != null) {
+                nbttagcompound1.putByteArray("BlockLight", serializablechunkdata_b.blockLight.getData());
             }
 
-            if (sectionData.skyLight != null) {
-                compoundTag2.putByteArray("SkyLight", sectionData.skyLight.getData());
+            if (serializablechunkdata_b.skyLight != null) {
+                nbttagcompound1.putByteArray("SkyLight", serializablechunkdata_b.skyLight.getData());
             }
 
-            if (!compoundTag2.isEmpty()) {
-                compoundTag2.putByte("Y", (byte)sectionData.y);
-                listTag.add(compoundTag2);
+            // Paper start - starlight
+            final int blockState = ((ca.spottedleaf.moonrise.patches.starlight.storage.StarlightSectionData)(Object)sectionData).starlight$getBlockLightState();
+            final int skyState = ((ca.spottedleaf.moonrise.patches.starlight.storage.StarlightSectionData)(Object)sectionData).starlight$getSkyLightState();
+
+            if (blockState > 0) {
+                sectionNBT.putInt(ca.spottedleaf.moonrise.patches.starlight.util.SaveUtil.BLOCKLIGHT_STATE_TAG, blockState);
+            }
+
+            if (skyState > 0) {
+                sectionNBT.putInt(ca.spottedleaf.moonrise.patches.starlight.util.SaveUtil.SKYLIGHT_STATE_TAG, skyState);
+            }
+            // Paper end - starlight
+
+            if (!nbttagcompound1.isEmpty()) {
+                nbttagcompound1.putByte("Y", (byte) serializablechunkdata_b.y);
+                nbttaglist.add(nbttagcompound1);
             }
         }
 
-        compoundTag.put("sections", listTag);
+        nbttagcompound.put("sections", nbttaglist);
         if (this.lightCorrect) {
-            compoundTag.putBoolean("isLightOn", true);
+            nbttagcompound.putBoolean("isLightOn", true);
         }
 
-        ListTag listTag2 = new ListTag();
-        listTag2.addAll(this.blockEntities);
-        compoundTag.put("block_entities", listTag2);
+        ListTag nbttaglist1 = new ListTag();
+
+        nbttaglist1.addAll(this.blockEntities);
+        nbttagcompound.put("block_entities", nbttaglist1);
         if (this.chunkStatus.getChunkType() == ChunkType.PROTOCHUNK) {
-            ListTag listTag3 = new ListTag();
-            listTag3.addAll(this.entities);
-            compoundTag.put("entities", listTag3);
+            ListTag nbttaglist2 = new ListTag();
+
+            nbttaglist2.addAll(this.entities);
+            nbttagcompound.put("entities", nbttaglist2);
             if (this.carvingMask != null) {
-                compoundTag.putLongArray("carving_mask", this.carvingMask);
+                nbttagcompound.putLongArray("carving_mask", this.carvingMask);
             }
         }
 
-        saveTicks(compoundTag, this.packedTicks);
-        compoundTag.put("PostProcessing", packOffsets(this.postProcessingSections));
-        CompoundTag compoundTag3 = new CompoundTag();
-        this.heightmaps.forEach((type, values) -> compoundTag3.put(type.getSerializationKey(), new LongArrayTag(values)));
-        compoundTag.put("Heightmaps", compoundTag3);
-        compoundTag.put("structures", this.structureData);
-        return compoundTag;
+        saveTicks(nbttagcompound, this.packedTicks);
+        nbttagcompound.put("PostProcessing", packOffsets(this.postProcessingSections));
+        CompoundTag nbttagcompound2 = new CompoundTag();
+
+        this.heightmaps.forEach((heightmap_type, along) -> {
+            nbttagcompound2.put(heightmap_type.getSerializationKey(), new LongArrayTag(along));
+        });
+        nbttagcompound.put("Heightmaps", nbttagcompound2);
+        nbttagcompound.put("structures", this.structureData);
+        // CraftBukkit start - store chunk persistent data in nbt
+        if (this.persistentDataContainer != null) { // SPIGOT-6814: Always save PDC to account for 1.17 to 1.18 chunk upgrading.
+            nbttagcompound.put("ChunkBukkitValues", this.persistentDataContainer);
+        }
+        // CraftBukkit end
+        // Paper start - starlight
+        if (this.lightCorrect && !this.chunkStatus.isBefore(net.minecraft.world.level.chunk.status.ChunkStatus.LIGHT)) {
+            // clobber vanilla value to force vanilla to relight
+            nbttagcompound.putBoolean("isLightOn", false);
+            // store our light version
+            nbttagcompound.putInt(ca.spottedleaf.moonrise.patches.starlight.util.SaveUtil.STARLIGHT_VERSION_TAG, ca.spottedleaf.moonrise.patches.starlight.util.SaveUtil.STARLIGHT_LIGHT_VERSION);
+        }
+        // Paper end - starlight
+        return nbttagcompound;
     }
 
     private static void saveTicks(CompoundTag nbt, ChunkAccess.PackedTicks schedulers) {
-        ListTag listTag = new ListTag();
+        ListTag nbttaglist = new ListTag();
+        Iterator iterator = schedulers.blocks().iterator();
 
-        for (SavedTick<Block> savedTick : schedulers.blocks()) {
-            listTag.add(savedTick.save(block -> BuiltInRegistries.BLOCK.getKey(block).toString()));
+        while (iterator.hasNext()) {
+            SavedTick<Block> ticklistchunk = (SavedTick) iterator.next();
+
+            nbttaglist.add(ticklistchunk.save((block) -> {
+                return BuiltInRegistries.BLOCK.getKey(block).toString();
+            }));
         }
 
-        nbt.put("block_ticks", listTag);
-        ListTag listTag2 = new ListTag();
+        nbt.put("block_ticks", nbttaglist);
+        ListTag nbttaglist1 = new ListTag();
+        Iterator iterator1 = schedulers.fluids().iterator();
 
-        for (SavedTick<Fluid> savedTick2 : schedulers.fluids()) {
-            listTag2.add(savedTick2.save(fluid -> BuiltInRegistries.FLUID.getKey(fluid).toString()));
+        while (iterator1.hasNext()) {
+            SavedTick<Fluid> ticklistchunk1 = (SavedTick) iterator1.next();
+
+            nbttaglist1.add(ticklistchunk1.save((fluidtype) -> {
+                return BuiltInRegistries.FLUID.getKey(fluidtype).toString();
+            }));
         }
 
-        nbt.put("fluid_ticks", listTag2);
+        nbt.put("fluid_ticks", nbttaglist1);
     }
 
     public static ChunkType getChunkTypeFromTag(@Nullable CompoundTag nbt) {
@@ -549,66 +733,94 @@
 
     @Nullable
     private static LevelChunk.PostLoadProcessor postLoadChunk(ServerLevel world, List<CompoundTag> entities, List<CompoundTag> blockEntities) {
-        return entities.isEmpty() && blockEntities.isEmpty() ? null : chunk -> {
+        return entities.isEmpty() && blockEntities.isEmpty() ? null : (chunk) -> {
             if (!entities.isEmpty()) {
                 world.addLegacyChunkEntities(EntityType.loadEntitiesRecursive(entities, world, EntitySpawnReason.LOAD));
             }
 
-            for (CompoundTag compoundTag : blockEntities) {
-                boolean bl = compoundTag.getBoolean("keepPacked");
-                if (bl) {
-                    chunk.setBlockEntityNbt(compoundTag);
+            Iterator iterator = blockEntities.iterator();
+
+            while (iterator.hasNext()) {
+                CompoundTag nbttagcompound = (CompoundTag) iterator.next();
+                boolean flag = nbttagcompound.getBoolean("keepPacked");
+
+                if (flag) {
+                    chunk.setBlockEntityNbt(nbttagcompound);
                 } else {
-                    BlockPos blockPos = BlockEntity.getPosFromTag(compoundTag);
-                    BlockEntity blockEntity = BlockEntity.loadStatic(blockPos, chunk.getBlockState(blockPos), compoundTag, world.registryAccess());
-                    if (blockEntity != null) {
-                        chunk.setBlockEntity(blockEntity);
+                    BlockPos blockposition = BlockEntity.getPosFromTag(nbttagcompound);
+                    // Paper start - do not read tile entities positioned outside the chunk
+                    ChunkPos chunkPos = chunk.getPos();
+                    if ((blockposition.getX() >> 4) != chunkPos.x || (blockposition.getZ() >> 4) != chunkPos.z) {
+                        LOGGER.warn("Tile entity serialized in chunk " + chunkPos + " in world '" + world.getWorld().getName() + "' positioned at " + blockposition + " is located outside of the chunk");
+                        continue;
+                    }
+                    // Paper end - do not read tile entities positioned outside the chunk
+                    BlockEntity tileentity = BlockEntity.loadStatic(blockposition, chunk.getBlockState(blockposition), nbttagcompound, world.registryAccess());
+
+                    if (tileentity != null) {
+                        chunk.setBlockEntity(tileentity);
                     }
                 }
             }
+
         };
     }
 
-    private static CompoundTag packStructureData(
-        StructurePieceSerializationContext context, ChunkPos pos, Map<Structure, StructureStart> starts, Map<Structure, LongSet> references
-    ) {
-        CompoundTag compoundTag = new CompoundTag();
-        CompoundTag compoundTag2 = new CompoundTag();
-        Registry<Structure> registry = context.registryAccess().lookupOrThrow(Registries.STRUCTURE);
+    private static CompoundTag packStructureData(StructurePieceSerializationContext context, ChunkPos pos, Map<Structure, StructureStart> starts, Map<Structure, LongSet> references) {
+        CompoundTag nbttagcompound = new CompoundTag();
+        CompoundTag nbttagcompound1 = new CompoundTag();
+        Registry<Structure> iregistry = context.registryAccess().lookupOrThrow(Registries.STRUCTURE);
+        Iterator iterator = starts.entrySet().iterator();
 
-        for (Entry<Structure, StructureStart> entry : starts.entrySet()) {
-            ResourceLocation resourceLocation = registry.getKey(entry.getKey());
-            compoundTag2.put(resourceLocation.toString(), entry.getValue().createTag(context, pos));
+        while (iterator.hasNext()) {
+            Entry<Structure, StructureStart> entry = (Entry) iterator.next();
+            ResourceLocation minecraftkey = iregistry.getKey((Structure) entry.getKey());
+
+            nbttagcompound1.put(minecraftkey.toString(), ((StructureStart) entry.getValue()).createTag(context, pos));
         }
 
-        compoundTag.put("starts", compoundTag2);
-        CompoundTag compoundTag3 = new CompoundTag();
+        nbttagcompound.put("starts", nbttagcompound1);
+        CompoundTag nbttagcompound2 = new CompoundTag();
+        Iterator iterator1 = references.entrySet().iterator();
 
-        for (Entry<Structure, LongSet> entry2 : references.entrySet()) {
-            if (!entry2.getValue().isEmpty()) {
-                ResourceLocation resourceLocation2 = registry.getKey(entry2.getKey());
-                compoundTag3.put(resourceLocation2.toString(), new LongArrayTag(entry2.getValue()));
+        while (iterator1.hasNext()) {
+            Entry<Structure, LongSet> entry1 = (Entry) iterator1.next();
+
+            if (!((LongSet) entry1.getValue()).isEmpty()) {
+                ResourceLocation minecraftkey1 = iregistry.getKey((Structure) entry1.getKey());
+
+                nbttagcompound2.put(minecraftkey1.toString(), new LongArrayTag((LongSet) entry1.getValue()));
             }
         }
 
-        compoundTag.put("References", compoundTag3);
-        return compoundTag;
+        nbttagcompound.put("References", nbttagcompound2);
+        return nbttagcompound;
     }
 
     private static Map<Structure, StructureStart> unpackStructureStart(StructurePieceSerializationContext context, CompoundTag nbt, long worldSeed) {
         Map<Structure, StructureStart> map = Maps.newHashMap();
-        Registry<Structure> registry = context.registryAccess().lookupOrThrow(Registries.STRUCTURE);
-        CompoundTag compoundTag = nbt.getCompound("starts");
+        Registry<Structure> iregistry = context.registryAccess().lookupOrThrow(Registries.STRUCTURE);
+        CompoundTag nbttagcompound1 = nbt.getCompound("starts");
+        Iterator iterator = nbttagcompound1.getAllKeys().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            ResourceLocation minecraftkey = ResourceLocation.tryParse(s);
+            Structure structure = (Structure) iregistry.getValue(minecraftkey);
 
-        for (String string : compoundTag.getAllKeys()) {
-            ResourceLocation resourceLocation = ResourceLocation.tryParse(string);
-            Structure structure = registry.getValue(resourceLocation);
             if (structure == null) {
-                LOGGER.error("Unknown structure start: {}", resourceLocation);
+                SerializableChunkData.LOGGER.error("Unknown structure start: {}", minecraftkey);
             } else {
-                StructureStart structureStart = StructureStart.loadStaticStart(context, compoundTag.getCompound(string), worldSeed);
-                if (structureStart != null) {
-                    map.put(structure, structureStart);
+                StructureStart structurestart = StructureStart.loadStaticStart(context, nbttagcompound1.getCompound(s), worldSeed);
+
+                if (structurestart != null) {
+                    // CraftBukkit start - load persistent data for structure start
+                    net.minecraft.nbt.Tag persistentBase = nbttagcompound1.getCompound(s).get("StructureBukkitValues");
+                    if (persistentBase instanceof CompoundTag) {
+                        structurestart.persistentDataContainer.putAll((CompoundTag) persistentBase);
+                    }
+                    // CraftBukkit end
+                    map.put(structure, structurestart);
                 }
             }
         }
@@ -618,21 +830,26 @@
 
     private static Map<Structure, LongSet> unpackStructureReferences(RegistryAccess registryManager, ChunkPos pos, CompoundTag nbt) {
         Map<Structure, LongSet> map = Maps.newHashMap();
-        Registry<Structure> registry = registryManager.lookupOrThrow(Registries.STRUCTURE);
-        CompoundTag compoundTag = nbt.getCompound("References");
+        Registry<Structure> iregistry = registryManager.lookupOrThrow(Registries.STRUCTURE);
+        CompoundTag nbttagcompound1 = nbt.getCompound("References");
+        Iterator iterator = nbttagcompound1.getAllKeys().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            ResourceLocation minecraftkey = ResourceLocation.tryParse(s);
+            Structure structure = (Structure) iregistry.getValue(minecraftkey);
 
-        for (String string : compoundTag.getAllKeys()) {
-            ResourceLocation resourceLocation = ResourceLocation.tryParse(string);
-            Structure structure = registry.getValue(resourceLocation);
             if (structure == null) {
-                LOGGER.warn("Found reference to unknown structure '{}' in chunk {}, discarding", resourceLocation, pos);
+                SerializableChunkData.LOGGER.warn("Found reference to unknown structure '{}' in chunk {}, discarding", minecraftkey, pos);
             } else {
-                long[] ls = compoundTag.getLongArray(string);
-                if (ls.length != 0) {
-                    map.put(structure, new LongOpenHashSet(Arrays.stream(ls).filter(packedPos -> {
-                        ChunkPos chunkPos2 = new ChunkPos(packedPos);
-                        if (chunkPos2.getChessboardDistance(pos) > 8) {
-                            LOGGER.warn("Found invalid structure reference [ {} @ {} ] for chunk {}.", resourceLocation, chunkPos2, pos);
+                long[] along = nbttagcompound1.getLongArray(s);
+
+                if (along.length != 0) {
+                    map.put(structure, new LongOpenHashSet(Arrays.stream(along).filter((i) -> {
+                        ChunkPos chunkcoordintpair1 = new ChunkPos(i);
+
+                        if (chunkcoordintpair1.getChessboardDistance(pos) > 8) {
+                            SerializableChunkData.LOGGER.warn("Found invalid structure reference [ {} @ {} ] for chunk {}.", new Object[]{minecraftkey, chunkcoordintpair1, pos});
                             return false;
                         } else {
                             return true;
@@ -646,28 +863,94 @@
     }
 
     private static ListTag packOffsets(ShortList[] lists) {
-        ListTag listTag = new ListTag();
+        ListTag nbttaglist = new ListTag();
+        ShortList[] ashortlist1 = lists;
+        int i = lists.length;
 
-        for (ShortList shortList : lists) {
-            ListTag listTag2 = new ListTag();
-            if (shortList != null) {
-                for (int i = 0; i < shortList.size(); i++) {
-                    listTag2.add(ShortTag.valueOf(shortList.getShort(i)));
+        for (int j = 0; j < i; ++j) {
+            ShortList shortlist = ashortlist1[j];
+            ListTag nbttaglist1 = new ListTag();
+
+            if (shortlist != null) {
+                for (int k = 0; k < shortlist.size(); ++k) {
+                    nbttaglist1.add(ShortTag.valueOf(shortlist.getShort(k)));
                 }
             }
 
-            listTag.add(listTag2);
+            nbttaglist.add(nbttaglist1);
         }
 
-        return listTag;
+        return nbttaglist;
+    }
+
+    // Paper start - starlight - convert from record
+    public static final class SectionData implements ca.spottedleaf.moonrise.patches.starlight.storage.StarlightSectionData { // Paper - starlight - our diff
+        private final int y;
+        @javax.annotation.Nullable
+        private final net.minecraft.world.level.chunk.LevelChunkSection chunkSection;
+        @javax.annotation.Nullable
+        private final net.minecraft.world.level.chunk.DataLayer blockLight;
+        @javax.annotation.Nullable
+        private final net.minecraft.world.level.chunk.DataLayer skyLight;
+
+        // Paper start - starlight - our diff
+        private int blockLightState = -1;
+        private int skyLightState = -1;
+
+        @Override
+        public final int starlight$getBlockLightState() {
+            return this.blockLightState;
+        }
+
+        @Override
+        public final void starlight$setBlockLightState(final int state) {
+            this.blockLightState = state;
+        }
+
+        @Override
+        public final int starlight$getSkyLightState() {
+            return this.skyLightState;
+        }
+
+        @Override
+        public final void starlight$setSkyLightState(final int state) {
+            this.skyLightState = state;
+        }
+        // Paper end - starlight - our diff
+
+        public SectionData(int y, @javax.annotation.Nullable net.minecraft.world.level.chunk.LevelChunkSection chunkSection, @javax.annotation.Nullable net.minecraft.world.level.chunk.DataLayer blockLight, @javax.annotation.Nullable net.minecraft.world.level.chunk.DataLayer skyLight) {
+            this.y = y;
+            this.chunkSection = chunkSection;
+            this.blockLight = blockLight;
+            this.skyLight = skyLight;
+        }
+
+        public int y() {
+            return y;
+        }
+
+        @javax.annotation.Nullable
+        public net.minecraft.world.level.chunk.LevelChunkSection chunkSection() {
+            return chunkSection;
+        }
+
+        @javax.annotation.Nullable
+        public net.minecraft.world.level.chunk.DataLayer blockLight() {
+            return blockLight;
+        }
+
+        @javax.annotation.Nullable
+        public net.minecraft.world.level.chunk.DataLayer skyLight() {
+            return skyLight;
+        }
+        // Paper end - starlight - convert from record
+
     }
 
     public static class ChunkReadException extends NbtException {
+
         public ChunkReadException(String message) {
             super(message);
         }
     }
-
-    public static record SectionData(int y, @Nullable LevelChunkSection chunkSection, @Nullable DataLayer blockLight, @Nullable DataLayer skyLight) {
-    }
 }
