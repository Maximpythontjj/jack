--- a/net/minecraft/world/entity/projectile/AbstractHurtingProjectile.java
+++ b/net/minecraft/world/entity/projectile/AbstractHurtingProjectile.java
@@ -18,14 +18,21 @@
 import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
+// CraftBukkit start
+import org.bukkit.event.entity.EntityRemoveEvent;
+// CraftBukkit end
 
 public abstract class AbstractHurtingProjectile extends Projectile {
-    public static final double INITAL_ACCELERATION_POWER = 0.1;
-    public static final double DEFLECTION_SCALE = 0.5;
-    public double accelerationPower = 0.1;
+
+    public static final double INITAL_ACCELERATION_POWER = 0.1D;
+    public static final double DEFLECTION_SCALE = 0.5D;
+    public double accelerationPower;
+    public float bukkitYield = 1; // CraftBukkit
+    public boolean isIncendiary = true; // CraftBukkit
 
     protected AbstractHurtingProjectile(EntityType<? extends AbstractHurtingProjectile> type, Level world) {
         super(type, world);
+        this.accelerationPower = 0.1D;
     }
 
     protected AbstractHurtingProjectile(EntityType<? extends AbstractHurtingProjectile> type, double x, double y, double z, Level world) {
@@ -47,18 +54,18 @@
     }
 
     @Override
-    protected void defineSynchedData(SynchedEntityData.Builder builder) {
-    }
+    protected void defineSynchedData(SynchedEntityData.Builder builder) {}
 
     @Override
     public boolean shouldRenderAtSqrDistance(double distance) {
-        double d = this.getBoundingBox().getSize() * 4.0;
-        if (Double.isNaN(d)) {
-            d = 4.0;
+        double d1 = this.getBoundingBox().getSize() * 4.0D;
+
+        if (Double.isNaN(d1)) {
+            d1 = 4.0D;
         }
 
-        d *= 64.0;
-        return distance < d * d;
+        d1 *= 64.0D;
+        return distance < d1 * d1;
     }
 
     protected ClipContext.Block getClipType() {
@@ -68,59 +75,64 @@
     @Override
     public void tick() {
         Entity entity = this.getOwner();
+
         this.applyInertia();
-        if (this.level().isClientSide || (entity == null || !entity.isRemoved()) && this.level().hasChunkAt(this.blockPosition())) {
-            HitResult hitResult = ProjectileUtil.getHitResultOnMoveVector(this, this::canHitEntity, this.getClipType());
-            Vec3 vec3;
-            if (hitResult.getType() != HitResult.Type.MISS) {
-                vec3 = hitResult.getLocation();
+        if (!this.level().isClientSide && (entity != null && entity.isRemoved() || !this.level().hasChunkAt(this.blockPosition()))) {
+            this.discard(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
+        } else {
+            HitResult movingobjectposition = ProjectileUtil.getHitResultOnMoveVector(this, this::canHitEntity, this.getClipType());
+            Vec3 vec3d;
+
+            if (movingobjectposition.getType() != HitResult.Type.MISS) {
+                vec3d = movingobjectposition.getLocation();
             } else {
-                vec3 = this.position().add(this.getDeltaMovement());
+                vec3d = this.position().add(this.getDeltaMovement());
             }
 
             ProjectileUtil.rotateTowardsMovement(this, 0.2F);
-            this.setPos(vec3);
+            this.setPos(vec3d);
             this.applyEffectsFromBlocks();
             super.tick();
             if (this.shouldBurn()) {
                 this.igniteForSeconds(1.0F);
             }
 
-            if (hitResult.getType() != HitResult.Type.MISS && this.isAlive()) {
-                this.hitTargetOrDeflectSelf(hitResult);
+            if (movingobjectposition.getType() != HitResult.Type.MISS && this.isAlive()) {
+                this.preHitTargetOrDeflectSelf(movingobjectposition); // CraftBukkit - projectile hit event
             }
 
             this.createParticleTrail();
-        } else {
-            this.discard();
         }
     }
 
     private void applyInertia() {
-        Vec3 vec3 = this.getDeltaMovement();
-        Vec3 vec32 = this.position();
-        float g;
+        Vec3 vec3d = this.getDeltaMovement();
+        Vec3 vec3d1 = this.position();
+        float f;
+
         if (this.isInWater()) {
-            for (int i = 0; i < 4; i++) {
-                float f = 0.25F;
-                this.level()
-                    .addParticle(ParticleTypes.BUBBLE, vec32.x - vec3.x * 0.25, vec32.y - vec3.y * 0.25, vec32.z - vec3.z * 0.25, vec3.x, vec3.y, vec3.z);
+            for (int i = 0; i < 4; ++i) {
+                float f1 = 0.25F;
+
+                this.level().addParticle(ParticleTypes.BUBBLE, vec3d1.x - vec3d.x * 0.25D, vec3d1.y - vec3d.y * 0.25D, vec3d1.z - vec3d.z * 0.25D, vec3d.x, vec3d.y, vec3d.z);
             }
 
-            g = this.getLiquidInertia();
+            f = this.getLiquidInertia();
         } else {
-            g = this.getInertia();
+            f = this.getInertia();
         }
 
-        this.setDeltaMovement(vec3.add(vec3.normalize().scale(this.accelerationPower)).scale((double)g));
+        this.setDeltaMovement(vec3d.add(vec3d.normalize().scale(this.accelerationPower)).scale((double) f));
     }
 
     private void createParticleTrail() {
-        ParticleOptions particleOptions = this.getTrailParticle();
-        Vec3 vec3 = this.position();
-        if (particleOptions != null) {
-            this.level().addParticle(particleOptions, vec3.x, vec3.y + 0.5, vec3.z, 0.0, 0.0, 0.0);
+        ParticleOptions particleparam = this.getTrailParticle();
+        Vec3 vec3d = this.position();
+
+        if (particleparam != null) {
+            this.level().addParticle(particleparam, vec3d.x, vec3d.y + 0.5D, vec3d.z, 0.0D, 0.0D, 0.0D);
         }
+
     }
 
     @Override
@@ -162,6 +174,7 @@
         if (nbt.contains("acceleration_power", 6)) {
             this.accelerationPower = nbt.getDouble("acceleration_power");
         }
+
     }
 
     @Override
@@ -173,27 +186,17 @@
     public Packet<ClientGamePacketListener> getAddEntityPacket(ServerEntity entityTrackerEntry) {
         Entity entity = this.getOwner();
         int i = entity == null ? 0 : entity.getId();
-        Vec3 vec3 = entityTrackerEntry.getPositionBase();
-        return new ClientboundAddEntityPacket(
-            this.getId(),
-            this.getUUID(),
-            vec3.x(),
-            vec3.y(),
-            vec3.z(),
-            entityTrackerEntry.getLastSentXRot(),
-            entityTrackerEntry.getLastSentYRot(),
-            this.getType(),
-            i,
-            entityTrackerEntry.getLastSentMovement(),
-            0.0
-        );
+        Vec3 vec3d = entityTrackerEntry.getPositionBase();
+
+        return new ClientboundAddEntityPacket(this.getId(), this.getUUID(), vec3d.x(), vec3d.y(), vec3d.z(), entityTrackerEntry.getLastSentXRot(), entityTrackerEntry.getLastSentYRot(), this.getType(), i, entityTrackerEntry.getLastSentMovement(), 0.0D);
     }
 
     @Override
     public void recreateFromPacket(ClientboundAddEntityPacket packet) {
         super.recreateFromPacket(packet);
-        Vec3 vec3 = new Vec3(packet.getXa(), packet.getYa(), packet.getZa());
-        this.setDeltaMovement(vec3);
+        Vec3 vec3d = new Vec3(packet.getXa(), packet.getYa(), packet.getZa());
+
+        this.setDeltaMovement(vec3d);
     }
 
     public void assignDirectionalMovement(Vec3 velocity, double accelerationPower) {
@@ -205,9 +208,10 @@
     protected void onDeflection(@Nullable Entity deflector, boolean fromAttack) {
         super.onDeflection(deflector, fromAttack);
         if (fromAttack) {
-            this.accelerationPower = 0.1;
+            this.accelerationPower = 0.1D;
         } else {
-            this.accelerationPower *= 0.5;
+            this.accelerationPower *= 0.5D;
         }
+
     }
 }
